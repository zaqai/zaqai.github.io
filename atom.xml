<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://blog.zaqai.com/atom.xml" rel="self"/>
  
  <link href="https://blog.zaqai.com/"/>
  <updated>2024-06-10T11:58:14.723Z</updated>
  <id>https://blog.zaqai.com/</id>
  
  <author>
    <name>zaqai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github 私有仓库clone push pull</title>
    <link href="https://blog.zaqai.com/2024/06/10/github%20%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93clone%20push%20pull/"/>
    <id>https://blog.zaqai.com/2024/06/10/github%20%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93clone%20push%20pull/</id>
    <published>2024-06-10T12:18:03.178Z</published>
    <updated>2024-06-10T11:58:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>github 私有仓库clone push pull</h1><blockquote><p>有些情况下, 我们的代码还不能公开到github, 但是使用github管理代码版本真的很方便, 所以便有了这个需求</p></blockquote><h2 id="ssh-推荐">ssh(推荐)</h2><p>适用于你自己的服务器, 你可以将服务器的公钥放在github, 然后clone时使用<code>git@</code>的形式, 注意不是<code>https</code>, 之后的push pull都正常了.<br>但是, 由于网络原因, 大家都懂, 很恶心.<br>可以配置个代理<br><code>vim ~/.ssh/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand nc -v -x ip:port %h %p</span><br></pre></td></tr></table></figure><p>就可以畅通无阻了.</p><h2 id="token">token</h2><p>适用于服务器不是你的而你还需要用这台服务器, 使用token保密性高一点. 毕竟将服务器的公钥放在github就是完全信任这个服务器了.<br>在你自己的github seetings里, 有一个token, <a href="https://github.com/settings/tokens?type=beta">https://github.com/settings/tokens?type=beta</a><br>这两个token我忘记用的是哪个了, 好像是都可以<br>设置token的访问权限, 对你的私有仓库可读写<br>之后clone时使用<code>https://user:token@github.com/username/repo.git</code>就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;github 私有仓库clone push pull&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;有些情况下, 我们的代码还不能公开到github, 但是使用github管理代码版本真的很方便, 所以便有了这个需求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ssh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 CLIP-EBC_CLIP Can Count Accurately through Enhanced Blockwise Classification</title>
    <link href="https://blog.zaqai.com/2024/06/10/CLIP-EBC_CLIP%20Can%20Count%20Accurately%20through%20Enhanced%20Blockwise%20Classification/"/>
    <id>https://blog.zaqai.com/2024/06/10/CLIP-EBC_CLIP%20Can%20Count%20Accurately%20through%20Enhanced%20Blockwise%20Classification/</id>
    <published>2024-06-10T12:18:03.178Z</published>
    <updated>2024-06-10T11:58:02.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Yiming-M/CLIP-EBC">https://github.com/Yiming-M/CLIP-EBC</a><br>2024.3 arxiv<br>55.0 and 6.3 on ShanghaiTech part A and part B<br>基于分类的计数方法，提出了Enhanced Blockwise Classification框架，现有的基于回归的方法可以无缝地集成到EBC框架中<br>EBC在discretization, label correction, and loss function三个方面提高基于分类的计数方法的性能<br>基于EBC，提出CLIP-EBC，完全使用CLIP来生成人群密度图</p></blockquote><blockquote><p>基于回归的计数方法通常是编码器解码器架构，回归密度图<br>基于分类的计数方法，将[0,♾️]的整数分为不重叠的间隔，目标就是将预测的数值分类到正确的间隔。可以增加大数值的样本数量，解决计数值的长尾分布问题</p></blockquote><h2 id="方法">方法</h2><h3 id="Enhanced-Blockwise-Classification-EBC">Enhanced Blockwise Classification(EBC)</h3><p>基于回归生成密度图的方法面临大计数值的样本不足的问题<br>EBC将计数值分组到bin中，以增加每个bin的样本量，从而缓解了样本不平衡的问题。<br><img src="https://oss.zaqai.com/img/202404161627519.png" alt="image.png"><br><img src="https://math.now.sh?inline=%5C%7B%5Cmathcal%7BB%7D_i%5Cmid%20i%3D1%2C%5Ccdots%2Cn%5C%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>  是n个提前定义好的箱子，实际上表示一个整数的范围，如10-20<br><img src="https://math.now.sh?inline=%5Cboldsymbol%7BP%7D%5E*%3An%5Ctimes%7Bh%7D%5Ctimes%7Bw%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>  h=H//r, w=H//r, r是模型相关的放缩因子<br><img src="https://math.now.sh?inline=%5Cboldsymbol%7BP%7D_%7B%3A%2Ci%2Cj%7D%5E*" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>  表示该位置的可能性分数，共有n个值，对应n个箱子<br><img src="https://math.now.sh?inline=%5Cboldsymbol%7BY%7D_%7Bi%2Cj%7D%5E*%3D%5Csum_%7Bk%3D1%7D%5Ena_k%5Ccdot%5Cboldsymbol%7BP%7D_%7Bk%2Ci%2Cj%7D%5E*" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>  Y是预测的密度图，a是箱子的代表值(如范围的中间值)<br>现有的基于回归的方法可以很容易地通过只改变输出维度来定制以适应EBC。<br><img src="https://oss.zaqai.com/img/202404161655302.png" alt="image.png"></p><h4 id="离散化">离散化</h4><p>高斯平滑获取GT密度图的方法，由于人头尺度不同，使用固定的核大小，可能会引入噪声<br><img src="https://oss.zaqai.com/img/202404161706990.png" alt="image.png"><br>作者提出绕过高斯平滑，如果一个人头特定的区域内，只用那个块来预测这个人头的存在，同时排除其他块来做出这样的预测。</p><p>因为计数值可能不符合均匀分布，使用中间值作为bin的代表值不是最优的<br>提出使用每个箱子中的平均计数值作为代表点<br><img src="https://math.now.sh?inline=a_i%3D%5Cfrac1%7B%7C%5Cmathcal%7BB%7D_i%7C%7D%5Csum_%7Bk%3D1%7D%5EM1%28c_k%5Cin%5Cmathcal%7BB%7D_i%29%5Ccdot%20c_k%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h4 id="标签校正">标签校正</h4><p>对于特别密集的人群，实际上可能包含很多人头，但受限于分辨率，只能观察到较小的人头数<br>作者将固定大小图像块中可观察到的人的最大数量限制在一个小的范围内，完全由补丁大小决定。<br>最大数量<img src="https://math.now.sh?inline=m%3D%28r%2F%2Fs%29%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>，s是一个人头可被识别的最小尺寸，r是块大小<br><img src="https://oss.zaqai.com/img/202404162235888.png" alt="image.png"></p><h4 id="损失函数">损失函数</h4><p>之前的基于分类的方法的损失函数只关注分类误差，忽视了预测值和GT的差异，尽管两个概率分布分类错误率相同，但他们可能具有不同的期望值，即它们在样本空间上的平均值可能不同<br>距离感知交叉熵损失（DACE）<br><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7D%5Cmathcal%7BL%7D_%7B%5Cmathrm%7BDACE%7D%7D%3D%26%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bclass%7D%7D%28%5Cboldsymbol%7BP%7D%5E*%2C%5Cboldsymbol%7BP%7D%29%2B%5Clambda%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bcount%7D%7D(%5Cboldsymbol%7BY%7D%5E*%2C%5Cboldsymbol%7BY%7D)%5C%5C%26%3D-%5Csum_%7Bi%3D1%7D%5E%7BH%2F%2Fr%7D%5Csum_%7Bj%3D1%7D%5E%7BW%2F%2Fr%7D%5Csum_%7Bk%3D1%7D%5En%5Cmathbb%7B1%7D(%5Cboldsymbol%7BP%7D_%7Bk%2Ci%2Cj%7D%3D1)%5Clog%5Cboldsymbol%7BP%7D_%7Bk%2Ci%2Cj%7D%5E*%5C%5C%26%2B%5Clambda%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bcount%7D%7D(%5Cboldsymbol%7BY%7D%5E*%2C%5Cboldsymbol%7BY%7D)%2C%5Cend%7Baligned%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>P是one-hot GT概率图，<img src="https://math.now.sh?inline=P%5E*" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>是预测出的概率图，维度[n,h,w],n是箱子的数量<br>Y是密度图</p><h3 id="CLIP-EBC">CLIP-EBC</h3><p><img src="https://oss.zaqai.com/img/202404161627519.png" alt="image.png"><br>CLIP-EBC对CLIP的图像编码器最后的层做了修改，去除池化层，用1×1卷积替换线性投影层。这种修改允许保存本地信息，这在人群计数中起着至关重要的作用。输出[d,h,w]的特征图，h=H//r, r是patch尺寸<br>文本提示</p><blockquote><p>There is/are bi person/people<br>There is/are between min(Bi) and max(Bi) person/people<br>There are more than m people</p></blockquote><h2 id="性能">性能</h2><p><img src="https://oss.zaqai.com/img/202404162329604.png" alt="image.png"><br>EBC确实有效，CLIP-EBC (ResNet50, ours)  ResNet50用在了哪里？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Yiming-M/CLIP-EBC&quot;&gt;https://github.com/Yiming-M/CLIP-EBC&lt;/a&gt;&lt;br&gt;
2024.3 arxiv&lt;br&gt;
55.0 and 6.3 on</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 Diffuse-Denoise-Count：Accurate Crowd-Counting with Diffusion Models</title>
    <link href="https://blog.zaqai.com/2024/06/10/Diffuse-Denoise-Count%EF%BC%9AAccurate%20Crowd-Counting%20with%20Diffusion%20Models/"/>
    <id>https://blog.zaqai.com/2024/06/10/Diffuse-Denoise-Count%EF%BC%9AAccurate%20Crowd-Counting%20with%20Diffusion%20Models/</id>
    <published>2024-06-10T12:18:03.178Z</published>
    <updated>2024-06-10T11:58:02.487Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>又名CrowdDiff: Multi-hypothesis Crowd Density Estimation using Diffusion Models<br>CVPR’24<br>第一个使用diffusion做人群计数和生成密度图</p><p>使用高斯核生成密度图，存在背景噪声积累和密度损失的问题。<br>小核可以避免临近密度的干扰。这有助于保持密度像素值的边界和分布，但回归网络使用小核来生成GT是无效的。ineffective</p></blockquote><p>本文提出使用条件扩散模型来预测密度图，因为扩散模型在生成过程中对训练数据具有高保真度。<br>提出了CrowdDiff，使用反向扩散过程生成人群密度图。<br>此外，由于扩散过程的中间时间步长是有噪声的，我们在训练过程中加入一个回归分支来进行直接人群估计，以改进特征学习。<br>由于扩散模型的随机性，引入了生成多重密度图并融合来提高计数性能。<br>为了避免密度损失，通过阈值像素密度值来计算预测密度图中观察到的数量，消除了背景噪声的影响，因为不需要密度像素值相加。</p><h2 id="CrowdDiff">CrowdDiff</h2><p>预测条件人群图像的每个时间步长中xt的噪声量，并应用反向扩散过程最终得到x0<br><img src="https://oss.zaqai.com/img/202404241539502.png" alt="image.png"></p><h3 id="3-1-小核">3.1 小核</h3><p>扩散过程需要一个密度图来学习人群密度的条件分布。<br>高斯核的分布与所得到的密度图之间的散度随核的大小和方差的增加而增加，特别是对于拥挤的场景。<br><img src="https://oss.zaqai.com/img/202404241547912.png" alt="image.png"></p><p>小核提供了另一种人群计数路径，而不对密度图求和。<br>人群计数可以通过简单地计算可观察到的核来获得。<br><img src="https://oss.zaqai.com/img/202404241931746.png" alt="image.png"></p><p>我们对密度图进行阈值化，并得到每个核的位置<br>然后，将人群计数计算为位置的总数。这提供了一种避免生成的密度图中的背景噪声的方法，并通过检测人群密度图中的这些窄核来获得人群计数。</p><h3 id="3-2-计数的联合学习">3.2. 计数的联合学习</h3><p>一个特定时间步长t的去噪网络的中间特征集为<br><img src="https://math.now.sh?inline=%5Cmathcal%7BZ%7D_t%3D%5C%7B%5Cmathbf%7Bz%7D_t%5E1%2C%5Cmathbf%7Bz%7D_t%5E2%2C%5Cldots%2C%5Cmathbf%7Bz%7D_t%5Ed%5C%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>其中，<img src="https://math.now.sh?inline=z%5E%E2%88%97_t" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>是解码器对应特征级别上的表示向量<br>对每个<img src="https://math.now.sh?inline=z%5E%E2%88%97_t" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>执行全局平均池化，然后将其连接起来，构造一个单一的特征向量<img src="https://math.now.sh?inline=z_t" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>。然后通过回归网络来估计不同噪声水平下的计数。<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Bcount%7D%3D%5Cmathbb%7BE%7D_%7B%5Cmathbf%7Bx_0%7D%2C%5Cmathbf%7By%7D%2Ct%7D%5Cleft%5B%5Clambda_t%5C%7C%5Cbar%7Bc_t%7D-c%5C%7C_1%5Cright%5D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Boverall%7D%3D%5Cmathcal%7BL%7D_%7Bhybrid%7D%2B%5Clambda_%7Bcount%7D%5Cmathcal%7BL%7D_%7Bcount%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h3 id="3-3-随机密度图的融合">3.3. 随机密度图的融合</h3><p>由于diffusion的随机性，同一张图片可能生成不同的密度图，将不同的密度图融合可以提高性能，因为可以互补，可能某个密度图包含其他密度图不包含的密度<br>我们首先通过密度阈值法计算密度核的位置，找到了这些位置，就会为每个密度图构建一个点图，称为“人群图”。<br>使用结构相似度指数度量（SSIM）衡量来自不同实现的人群图之间的不同，</p><p>比如四张实现，对于一张人群图，与其他三个计算SSIM，这三个SSIM的和作为这张人群图的相似度分数<br>相似度分数最小的人群图可能包含原人群图不包含的信息</p><p><img src="https://oss.zaqai.com/img/202404241847522.png" alt="image.png"></p><h2 id="性能">性能</h2><p>小核的使用通过减少密度值的损失，改善了密集区域的计数结果。其次，我们通过用阈值法代替密度求和，消除了背景噪声对人群计数的影响。<br><img src="https://oss.zaqai.com/img/202404241854925.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;又名CrowdDiff: Multi-hypothesis Crowd Density Estimation using Diffusion Models&lt;br&gt;
CVPR’24&lt;br&gt;
第一个使用diffusion做人群计数和生成密度图&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 Focus for Free in Density-Based Counting</title>
    <link href="https://blog.zaqai.com/2024/06/10/Focus%20for%20Free%20in%20Density-Based%20Counting/"/>
    <id>https://blog.zaqai.com/2024/06/10/Focus%20for%20Free%20in%20Density-Based%20Counting/</id>
    <published>2024-06-10T12:18:03.178Z</published>
    <updated>2024-06-10T11:58:01.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Zenglin Shi1 · Pascal Mettes2 · Cees G. M. Snoek2<br>IJCV  Received: 8 June 2023 / Accepted: 1 January 2024</p></blockquote><blockquote><p>大部分方法只使用点标注生成GT密度图，文章提出点标注还有其他用途来帮助计数，并且可以和任意网络结构和损失函数兼容。<br>- 模拟遮挡，相当于数据增强<br>- 前景蒸馏，从点标注生成前景掩模，网络可以不受背景干扰，只提取前景知识<br>- focus-for-free，会议版本的文章，将监督聚焦于分割和全局密度分类</p></blockquote><p>通常的做法：通过点标注获得GT密度图，训练网络将输入图片映射到密度图，推理时将网络输出的密度图求和得到数量。基于此，提出三种方法利用点标注提高计数准确率。</p><h2 id="模拟遮挡">模拟遮挡</h2><blockquote><p>现有的计数方法对于遮挡和密集场景效果不好，也缺少足够的密集场景的数据来训练</p></blockquote><p>图片中的物体<img src="https://math.now.sh?inline=%5Cmathcal%7BO%7D_%7Bi%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>=<img src="https://math.now.sh?inline=%28x_i%2Cy_i%2C2%5Csigma_i%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>使用<img src="https://math.now.sh?inline=%5Cmathcal%7BO%7D_%7Bcopy%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>来遮挡<img src="https://math.now.sh?inline=%5Cmathcal%7BO%7D_%7Bocc%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7Dx_%7Bpaste%7D%26%3D%5Clfloor%20r%5Ccdot%20cos%28%5Ctheta%29%5Crfloor%2Bx_%7Bocc%7D%2C%5C%5Cy_%7Bpaste%7D%26%3D%5Clfloor%20r%5Ccdot%20sin(%5Ctheta)%5Crfloor%2By_%7Bocc%7D%5Cend%7Baligned%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=r%3Dr_%7Bcopy%7D%2Br_%7Bocc%7D%5Cepsilon_%7Br%7D%5Cmathrm%7B~and~%7D%5Ctheta%5Cmathrm%7B%3D%7D2%5Cpi%5Cepsilon_%7B%5Ctheta%7D.%5Cepsilon_%7Br%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://oss.zaqai.com/img/202403201841083.png" alt="image.png"></p><h3 id="融合边缘">融合边缘</h3><blockquote><p>将一个物体粘贴到其他地方，物体边缘变化大，不利于训练</p></blockquote><h3 id="确定遮挡强度">确定遮挡强度</h3><blockquote><p>根据原图片遮挡等级确定模拟遮挡的强度</p></blockquote><p>定义了一种方法计算遮挡等级</p><h3 id="效果">效果</h3><p>Cutout和CutMix是遮挡增强的方法，他们不能产生新的遮挡样本<br>Cutout随机剔除一块区域，CutMix将一块区域替换为其他图片的一块区域<br><img src="https://oss.zaqai.com/img/202403201809013.png" alt="image.png"></p><h2 id="前景蒸馏">前景蒸馏</h2><blockquote><p>不受背景的影响，生成更好的密度图</p></blockquote><p>将传统的<img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Bd%7D%3D%5Cell_%7Bp%7D%28f_%7Bd%7D(I%29-D)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>变为前景和背景两部分<img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Bd%7D%3D%5Cell_%7Bp%7D%28f_%7Bd%7D(I%29_%7Bbg%7D)%2B%5Cell_%7Bp%7D(f_%7Bd%7D(I)_%7Bfg%7D-D_%7Bfg%7D)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><strong>两个问题</strong></p><h3 id="辅助网络">辅助网络</h3><p>训练辅助网络，网络输入的图片背景是黑色的（通过点标注区分前景背景），来专门学习前景的本质特征。<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Ba%7D%3D%5Cell_%7Bp%7D%5Cbig%28f_%7Ba%7D(I%5Codot%20S%29-D%5Cbig)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>S表示前景掩码</p><p><img src="https://math.now.sh?inline=S%28p%29%3D%5Cbegin%7Bcases%7D1%26%5Ctext%7Bif%7D%5Cexists_%7BP%5Cin%5Cmathcal%7BP%7D%7D%5Cbig(%7C%7Cp-P%7C%7C%5E2%5Cleq%5Csigma_P%5E2%5Cbig)%2C%5C%5C0%26%5Ctext%7Botherwise%7D.%5Cend%7Bcases%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>如果像素点p的<img src="https://math.now.sh?inline=%5Csigma_P" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>半径范围内有点P，这个像素点的值为1</p><h3 id="蒸馏损失">蒸馏损失</h3><p>辅助网络可以提前预训练，训练好之后拿来用<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7Bd%7D%3D%5Cell_%7Bp%7D%28D%5E%7B%5Cprime%7D-f_%7Ba%7D(I%5Codot%20S%29)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=D%5E%7B%5Cprime%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>表示预测的密度图</p><h2 id="局部和全局关注">局部和全局关注</h2><h3 id="局部分割关注">局部分割关注</h3><blockquote><p>靠近点标注的像素应该被关注，远离的像素应该被忽视，因为不相关的像素会误导损失函数</p></blockquote><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_s%3D%5Csum%5Climits_%7Bl%5Cin%5C%7B0%2C1%5C%7D%7D-%5Calpha%5ElS%5El%281-S%5E%7B%5Cprime%7D%29%5E%7B%5Cgamma_s%7Dlog(S%5E%7B%5Cprime%7D)%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_d%3D%5Cell_p%5Cbig%28f_d(I%29%5Codot%20f_s(I)-D%5Cbig)%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h3 id="全局密度关注">全局密度关注</h3><p><img src="https://math.now.sh?inline=G_%7Bj%2Ci%7D%3D%5Cfrac%7B%7C%5Cmathcal%7BP%7D_%7Bj%2Ci%7D%7C%7D%7BL%7D%2CL%3D%5Cleft%5Clfloor%5Cmax_%7Bi%3D1%2C..%2CN%7D%5Cleft%28%5Cfrac%7B%7C%5Cmathcal%7BP%7D_i%7C%7D%7BZ_i%7D%5Ccdot%20Z_%7Bj%2Ci%7D%5Cright%29%2FM%5Cright%5Crfloor%2B1." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_c%3D%5Csum_%7Bl%5Cin%5C%7B0%2C1%2C..%2CM%5C%7D%7D-G%5El%281-G%5E%7B%5Cprime%7D%29%5E%7B%5Cgamma_c%7Dlog(G%5E%7B%5Cprime%7D)%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h2 id="流程">流程</h2><p>第一阶段使用<img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_a" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>训练辅助网络来执行前景蒸馏<br>第二阶段使用<img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%3D%5Cmathcal%7BL%7D_%7Bd%7D%2B%5Clambda_%7Bs%7D%5Cmathcal%7BL%7D_%7Bs%7D%2B%5Clambda_%7Bc%7D%5Cmathcal%7BL%7D_%7Bc%7D%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>对关注点进行训练，将关注点融合到计数网络中<br>模拟遮挡增强在两个阶段都用到了</p><p><img src="https://oss.zaqai.com/img/202403201808940.png" alt="image.png"></p><p><img src="https://oss.zaqai.com/img/202403201956993.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Zenglin Shi1 · Pascal Mettes2 · Cees G. M. Snoek2&lt;br&gt;
IJCV  Received: 8 June 2023 / Accepted: 1 January 2024&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读 Point, Segment and Count_ A Generalized Framework for Object Counting</title>
    <link href="https://blog.zaqai.com/2024/06/10/Point,%20Segment%20and%20Count_%20A%20Generalized%20Framework%20for%20Object%20Counting/"/>
    <id>https://blog.zaqai.com/2024/06/10/Point,%20Segment%20and%20Count_%20A%20Generalized%20Framework%20for%20Object%20Counting/</id>
    <published>2024-06-10T12:18:03.178Z</published>
    <updated>2024-06-10T11:58:01.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CVPR 2024<br><a href="https://github.com/Hzzone/PseCo">https://github.com/Hzzone/PseCo</a></p></blockquote><p>提出了基于检测的零样本和小样本类别无关的通用计数框架（检测=计数+定位）<br>使用了SAM将所有可能的物体分割成掩码proposal，使用CLIP对proposal分类来计数<br>直接使用SAM面临效率低和小的稠密物体无法识别的问题<br>首先提出了一个类别无关的物体定位器，为SAM提供准确而且最少的点提示，降低计算成本，而且避免了小对象的丢失。<br>此外，提出了一种广义的对象分类器，利用CLIP图像/文本嵌入作为分类器，通过层次知识蒸馏，以获得层次掩模proposal之间的区别</p><p><img src="https://oss.zaqai.com/img/202403261515628.png" alt="image.png"></p><h2 id="point-decoder">point decoder</h2><p>对于SAM而言，在一张图片上均匀生成点（网格形式）作为prompts，如果点所在的位置有物体，SAM就可以生成该物体的mask，但是网格形式生成点，点不能保证落到所有物体上，特别是小物体。虽然可以让点更稠密，生成更多的点，但是效率不高</p><p>所以要训练一个网络来生成点，让点尽可能多的落到物体上，而不是背景上，从而提高效率。<br>本文将这个问题看作关键点预测问题，提出了point decoder，和SAM的mask decoder架构相同，并使用mask decoder来初始化。<br>输入图片  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BI%7D%5Cin%5Cmathbb%7BR%7D%5E%7BH%5Ctimes%20W%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>，输出关键点热力图  <img src="https://math.now.sh?inline=%5Cwidehat%7B%5Cboldsymbol%7BH%7D%7D%5Cin%5B0%2C1%5D%5E%7B%5Cfrac%7BH%7D%7Bs%7D%5Ctimes%5Cfrac%7BW%7D%7Bs%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>，s是stride</p><h3 id="训练point-decoder">训练point decoder</h3><p>首先使用网格生成点，输入进SAM得到物体的mask，根据物体轮廓计算出物体中心点，和GT point结合得到GT热力图H<br>（只使用GT point会造成对训练集类别的过拟合，而且泛化能力差）<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bpoint%7D%7D%3D%5C%7C%5Cwidehat%7BH%7D-H%5C%7C_2%5E2." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://oss.zaqai.com/img/202403261737212.png" alt="image.png"></p><h3 id="广义的物体分类器">广义的物体分类器</h3><p>旨在提供关于图像/文本查询的分数。</p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%5Cmathrm%7Bcls%7D%3D%5Coperatorname%7BBCE%7D%28%5Cboldsymbol%7BWr%7D%2C%5Cboldsymbol%7Bc%7D%29%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>    <img src="https://math.now.sh?inline=%5Cboldsymbol%7BW%7D%5Cin%5Cmathbb%7BR%7D%5E%7BC%5Ctimes%20D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 是分类权重，由CLIP文本/图像嵌入向量构建，C是query的数量，D是CLIP嵌入向量的维度，r是区域特征，从ROI之后的图像特征中提取， c是GT标签，BCE是二元交叉熵损失</p><p>对没有见过的类别效果不好，因为简单地将分类损失应用于目标分类器，会削弱CLIP的zero-shot能力</p><h4 id="分层知识蒸馏">分层知识蒸馏</h4><p>对齐来自SAM的分层mask proposal的区域特征和CLIP图像嵌入。对于从同一点获得的mask proposal，根据区域特征的重叠程度，用CLIP嵌入向量来对区域特征进行区分。在此过程中，图像编码器可以被蒸馏到分类器中，分类辨别能力更强<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bkd%7D%7D%3D%5Cfrac1M%5Csum_%7Bi%3D1%7D%5EM%5Cmathrm%7BBCE%7D%28%5Cboldsymbol%7BW%7D%5E%7B%5Cprime%7D%5Cboldsymbol%7Br%7D%5E%7B(i%29%7D%2C%5Cboldsymbol%7Bc%7D%5E%7B%5Cprime%7D)%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>M是每个点的proposal数量， <img src="https://math.now.sh?inline=%5Cboldsymbol%7BW%5E%7B%5Cprime%7D%7D%5Cin%5Cmathbb%7BR%7D%5E%7BM%5Ctimes%20D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>是图像区域的嵌入向量</p><h3 id="总损失">总损失</h3><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%3D%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bpoint%7D%7D%2B%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bcls%7D%7D%2B%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bkd%7D%7D." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h2 id="results">results</h2><p>few-shot(density-based and detection-based methods)<br><img src="https://oss.zaqai.com/img/202403271936600.png" alt="image.png"></p><p>zero-shot(density-based and detection-based methods)<br><img src="https://oss.zaqai.com/img/202403271936791.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;CVPR 2024&lt;br&gt;
&lt;a href=&quot;https://github.com/Hzzone/PseCo&quot;&gt;https://github.com/Hzzone/PseCo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提出了基于检测的零样本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nps泛域名解析内网穿透</title>
    <link href="https://blog.zaqai.com/2024/03/28/nps%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://blog.zaqai.com/2024/03/28/nps%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2024-03-28T10:18:03.219Z</published>
    <updated>2024-03-28T02:43:23.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nps泛域名解析内网穿透"><a href="#nps泛域名解析内网穿透" class="headerlink" title="nps泛域名解析内网穿透"></a>nps泛域名解析内网穿透</h1><blockquote><p>有一个自己的服务器可以实现很多事情, 给自己带来便利.<br>但是首先要考虑网络问题, 毕竟自己也不可能一直都处于内网环境中.<br>一个解决方案便是云服务器, 带有公网ip, 但是配置稍微好一点的云服务器价格水涨船高.<br>我的解决方案是家里放置一个常年开机的linux主机, 使用配置低的云服务器做内网穿透.<br>搭配泛域名解析, 最终的效果就是在主机上配置一个反向代理之后, 直接可以使用https+二级域名的方式在任意网络环境(能连公网)下访问网站, 对自己来说操作完全透明, 就好像家里的主机有了公网ip一样.</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>域名的”*“记录解析到云服务器的公网ip上.</p><h2 id="云服务器nps"><a href="#云服务器nps" class="headerlink" title="云服务器nps"></a>云服务器nps</h2><p>按照网上的搭建步骤来, 直接运行二进制文件也行, docker也行<br><code>docker run -d --name nps --net=host -v /root/docker/nps/conf:/conf ffdfgdfg/nps</code><br>注意要修改配置文件’conf/nps.conf’<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy_port=80</span><br><span class="line">https_proxy_port=443</span><br></pre></td></tr></table></figure><br>https_proxy_port必须为443, 因为要实现https访问, 就要监听443端口.<br>新建完客户端之后, 在域名解析中新建记录, 主机填写”*.domain.com”, 目标直接填写443, 如果客户端是用docker+bridge启动的, 就要改成’172.17.0.1:443’.</p><h2 id="主机npc"><a href="#主机npc" class="headerlink" title="主机npc"></a>主机npc</h2><p>很简单, 直接docker吧<br><code>docker run -d --restart always --name npc --net=host ffdfgdfg/npc -server=...</code></p><h2 id="主机nginx-OpenResty"><a href="#主机nginx-OpenResty" class="headerlink" title="主机nginx/OpenResty"></a>主机nginx/OpenResty</h2><p>nginx监听443端口, 创建反向代理, 域名随便填写二级域名, 创建之后加上https.</p><h2 id="整体网络访问流程"><a href="#整体网络访问流程" class="headerlink" title="整体网络访问流程"></a>整体网络访问流程</h2><p>因为域名解析到了云服务器公网ip, 所有的访问先经过云服务器, 使用https是, 默认访问443端口, nps在监听443, 收到请求后将请求转发到主机的443端口, 主机的443端口由nginx监听, 收到请求后, 进行ssl握手协商, 并转发请求到真实服务端口.<br>再走一个反向流程到浏览器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nps泛域名解析内网穿透&quot;&gt;&lt;a href=&quot;#nps泛域名解析内网穿透&quot; class=&quot;headerlink&quot; title=&quot;nps泛域名解析内网穿透&quot;&gt;&lt;/a&gt;nps泛域名解析内网穿透&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有一个自己的服务器可以实现很多事情</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多模态物体计数论文阅读 Point, Segment and Count_ A Generalized Framework for Object Counting</title>
    <link href="https://blog.zaqai.com/2024/03/11/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%89%A9%E4%BD%93%E8%AE%A1%E6%95%B0%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Point,%20Segment%20and%20Count_%20A%20Generalized%20Framework%20for%20Object%20Counting/"/>
    <id>https://blog.zaqai.com/2024/03/11/%E5%A4%9A%E6%A8%A1%E6%80%81%E7%89%A9%E4%BD%93%E8%AE%A1%E6%95%B0%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Point,%20Segment%20and%20Count_%20A%20Generalized%20Framework%20for%20Object%20Counting/</id>
    <published>2024-03-10T20:18:03.287Z</published>
    <updated>2024-03-27T12:04:20.665Z</updated>
    
    <content type="html"><![CDATA[<h1>Point, Segment and Count_ A Generalized Framework for Object Counting</h1><blockquote><p>CVPR 2024<br><a href="https://github.com/Hzzone/PseCo">https://github.com/Hzzone/PseCo</a></p></blockquote><p>提出了基于检测的零样本和小样本类别无关的通用计数框架（检测=计数+定位）<br>使用了SAM将所有可能的物体分割成掩码proposal，使用CLIP对proposal分类来技术<br>面临效率低和小的稠密物体无法识别的问题<br>首先提出了一个类别无关的物体定位器，为SAM提供准确而且最少的点提示，降低计算成本，而且避免了小对象的丢失。<br>此外，提出了一种广义的对象分类器，利用CLIP图像/文本嵌入作为分类器，通过层次知识蒸馏，以获得层次掩模proposal之间的区别</p><p><img src="https://oss.zaqai.com/img/202403261515628.png" alt="image.png"></p><h2 id="point-decoder">point decoder</h2><p>对于SAM而言，在一张图片上均匀生成点（网格形式）作为prompts，如果点所在的位置有物体，SAM就可以生成该物体的mask，但是网格形式生成点，点不能保证落到所有物体上，特别是小物体。虽然可以让点更稠密，生成更多的点，但是效率不高</p><p>所以要训练一个网络来生成点，让点尽可能多的落到物体上，而不是背景上，从而提高效率。<br>本文将这个问题看作关键点预测问题，提出了point decoder，和SAM的mask decoder架构相同，并使用mask decoder来初始化。<br>输入图片  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BI%7D%5Cin%5Cmathbb%7BR%7D%5E%7BH%5Ctimes%20W%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>，输出关键点热力图  <img src="https://math.now.sh?inline=%5Cwidehat%7B%5Cboldsymbol%7BH%7D%7D%5Cin%5B0%2C1%5D%5E%7B%5Cfrac%7BH%7D%7Bs%7D%5Ctimes%5Cfrac%7BW%7D%7Bs%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>，s是stride</p><h3 id="训练point-decoder">训练point decoder</h3><p>首先使用网格生成点，输入进SAM得到物体的mask，根据物体轮廓计算出物体中心点，和GT point结合得到GT热力图H<br>（只使用GT point会造成对训练集类别的过拟合，而且泛化能力差）<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bpoint%7D%7D%3D%5C%7C%5Cwidehat%7BH%7D-H%5C%7C_2%5E2." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://oss.zaqai.com/img/202403261737212.png" alt="image.png"></p><h3 id="广义的物体分类器">广义的物体分类器</h3><p>旨在提供关于图像/文本查询的分数。</p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%5Cmathrm%7Bcls%7D%3D%5Coperatorname%7BBCE%7D%28%5Cboldsymbol%7BWr%7D%2C%5Cboldsymbol%7Bc%7D%29%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>    <img src="https://math.now.sh?inline=%5Cboldsymbol%7BW%7D%5Cin%5Cmathbb%7BR%7D%5E%7BC%5Ctimes%20D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 是分类权重，由CLIP文本/图像嵌入向量构建，C是query的数量，D是CLIP嵌入向量的维度，r是区域特征，从ROI之后的图像特征中提取， c是GT标签，BCE是二元交叉熵损失</p><p>对没有见过的类别效果不好，因为简单地将分类损失应用于目标分类器，会削弱CLIP的zero-shot能力</p><h4 id="分层知识蒸馏">分层知识蒸馏</h4><p>对齐来自SAM的分层mask proposal的区域特征和CLIP图像嵌入。对于从同一点获得的mask proposal，根据区域特征的重叠程度，用CLIP嵌入向量来对区域特征进行区分。在此过程中，图像编码器可以被蒸馏到分类器中，分类辨别能力更强<br><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bkd%7D%7D%3D%5Cfrac1M%5Csum_%7Bi%3D1%7D%5EM%5Cmathrm%7BBCE%7D%28%5Cboldsymbol%7BW%7D%5E%7B%5Cprime%7D%5Cboldsymbol%7Br%7D%5E%7B(i%29%7D%2C%5Cboldsymbol%7Bc%7D%5E%7B%5Cprime%7D)%2C" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br>M是每个点的proposal数量， <img src="https://math.now.sh?inline=%5Cboldsymbol%7BW%5E%7B%5Cprime%7D%7D%5Cin%5Cmathbb%7BR%7D%5E%7BM%5Ctimes%20D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>是图像区域的嵌入向量</p><h3 id="总损失">总损失</h3><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%3D%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bpoint%7D%7D%2B%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bcls%7D%7D%2B%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Bkd%7D%7D." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h2 id="results">results</h2><p>few-shot(density-based and detection-based methods)<br><img src="https://oss.zaqai.com/img/202403271936600.png" alt="image.png"></p><p>zero-shot(density-based and detection-based methods)<br><img src="https://oss.zaqai.com/img/202403271936791.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Point, Segment and Count_ A Generalized Framework for Object Counting&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;CVPR 2024&lt;br&gt;
&lt;a href=&quot;https://github.com/Hzz</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://blog.zaqai.com/2024/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.zaqai.com/2024/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-10T20:18:03.287Z</published>
    <updated>2024-03-27T03:21:44.202Z</updated>
    
    <content type="html"><![CDATA[<h1>设计模式</h1><h2 id="工厂方法模式">工厂方法模式</h2><p><img src="https://oss.zaqai.com/img/202403062134126.png" alt="image.png"><br>工厂模式是一种创建型设计模式, 有两套东西</p><h3 id="产品">产品</h3><p>通用产品是一个接口, 具体的产品要实现接口的功能.</p><h3 id="创建者">创建者</h3><p>基础的创建者是一个抽象类, 包含一个具体的方法和一个抽象的创建产品的方法, 具体的方法会调用创建产品的方法得到产品的实例, 再调用产品的功能方法<br>具体的创建者继承抽象类, 重写创建产品的方法, 由于具体的产品和具体的创建者一一对应, 这个方法直接new对应的具体产品并返回.</p><blockquote><p>具体的产品和具体的创建者一一对应<br>@Override注解是可选的</p></blockquote><h3 id="客户端调用">客户端调用</h3><p>客户端直接用具体的创建者(子类)初始化基础创建者(父类), 并调用父类的具体方法, 具体方法会调用创建产品的方法, 创建产品的方法是由具体子类实现的, 具体的子类来new出具体的产品.</p><h3 id="好处">好处</h3><p>需要新的产品, 直接定义产品类, 实现通用产品接口, 再创建一个对应的具体创建者, 继承父类, 重写抽象方法, 直接return new出来的新产品. 对于客户端的代码, 唯一的改动就是使用新的具体创建者来初始化基础创建者, 实现客户端和具体产品代码的解耦</p><h2 id="抽象工厂模式">抽象工厂模式</h2><p><img src="https://oss.zaqai.com/img/202403062243980.png" alt="image.png"></p><h3 id="产品-2">产品</h3><p>抽象产品是一个接口, 具体产品实现接口功能</p><h3 id="工厂">工厂</h3><p>抽象工厂是个接口, 有创建产品的方法, 具体的工厂实现方法, 直接return new出来的具体产品就行</p><h3 id="Application">Application</h3><p>构造函数接受一个具体的工厂实例(子类初始化父类), 调用工厂的创建产品的方法, 就得到了具体的产品实例, 就可以调用产品的功能</p><h3 id="好处-2">好处</h3><p>产生变动时, 客户端代码只需修改传入Application构造函数的具体工厂类型就可以, 实现客户端和具体产品代码的解耦</p><ul><li>单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li><li>开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li></ul><h2 id="单例模式">单例模式</h2><p>单例模式是一种创建型设计模式, 保证一个类只有一个实例, 并提供一个访问该实例的全局节点。<br>同时解决了两个问题， 所以违反了单一职责原则</p><ol><li>在类中添加一个私有静态成员变量用于保存单例实例。</li><li>声明一个公有静态构建方法用于获取单例实例。</li><li>在静态方法中实现&quot;延迟初始化&quot;。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li><li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refactoring_guru.singleton.example.thread_safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// The field must be declared volatile so that double check lock would work correctly.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;设计模式&lt;/h1&gt;
&lt;h2 id=&quot;工厂方法模式&quot;&gt;工厂方法模式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oss.zaqai.com/img/202403062134126.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;
工厂模式是一种创建型设计模式, 有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux无图形界面使用selenium自动登录爬取数据</title>
    <link href="https://blog.zaqai.com/2024/02/01/linux%E6%97%A0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8selenium%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>https://blog.zaqai.com/2024/02/01/linux%E6%97%A0%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8selenium%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2024-01-31T20:18:03.219Z</published>
    <updated>2024-03-27T13:12:39.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux无图形界面使用selenium自动登录爬取数据"><a href="#linux无图形界面使用selenium自动登录爬取数据" class="headerlink" title="linux无图形界面使用selenium自动登录爬取数据"></a>linux无图形界面使用selenium自动登录爬取数据</h1><blockquote><p>对于一些cookie有效期较长的场景, 我们可以在浏览器devtool直接复制网络请求的curl命令, 再通过<a href="https://curlconverter.com/python/">Convert curl commands to Python (curlconverter.com)</a>转换为python脚本, 这样会自动带上cookie.<br>但是对于cookie有效期较短或要求较为严格的场景, 就要使用selenium来模拟浏览器操作了, Selenium是广泛使用的模拟浏览器运行的库, 它是一个用于Web应用程序测试的工具.  Selenium测试直接运行在浏览器中，就像真正的用户在操作一样，并且支持大多数现代 Web 浏览器</p><p>由于无图形界面不能直观地看到浏览器状态, 建议在windows上调试好爬虫脚本之后再放在linux用</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2></blockquote><h3 id="系统依赖"><a href="#系统依赖" class="headerlink" title="系统依赖"></a>系统依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libxss1 libappindicator1 libindicator7</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装xvfb</span></span><br><span class="line"><span class="comment"># xvfb是一种虚拟的窗口服务器，可以模拟图形界面。</span></span><br><span class="line">sudo apt-get install xvfb</span><br></pre></td></tr></table></figure><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h4><p>要安装chrome和chromedriver, 并且版本一致, 一般chromedriver新版本难找, 所以chrome不要太新, 推荐一个网站<a href="https://googlechromelabs.github.io/chrome-for-testing/">Chrome for Testing availability (googlechromelabs.github.io)</a>, 下载匹配的版本即可<br>安装不用多说了, 直接解压, 写环境变量<br>我的版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└─[0] chromedriver --version</span><br><span class="line">ChromeDriver 122.0.6261.94 (880dbf29479c6152d5e4f08dfd3a96b30f919e56-refs/branch-heads/6261@&#123;<span class="comment">#960&#125;)</span></span><br><span class="line">(notebook) (base) ┌─[root@q-EQ] - [~] - [2024-02-29 08:57:36]</span><br><span class="line">└─[0] google-chrome --version</span><br><span class="line">Google Chrome 122.0.6261.94 </span><br></pre></td></tr></table></figure></p><h4 id="firefox-未测试"><a href="#firefox-未测试" class="headerlink" title="firefox(未测试)"></a>firefox(未测试)</h4><p>先下载driver <a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gtk3</span><br><span class="line">wget http://releases.mozilla.org/pub/firefox/releases/116.0.3/linux-x86_64/zh-CN/firefox-116.0.3.tar.bz2</span><br><span class="line">tar jxpvf firefox-116.0.3.tar.bz2</span><br><span class="line">sudo <span class="built_in">ln</span> -s /root/firefox/firefox /usr/bin/firefox</span><br></pre></td></tr></table></figure></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行创建conda环境</span></span><br><span class="line">pip install selenium -i https://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># pyvirtualdisplay是一个Python库，用于在无图形界面环境下触发xvfb。</span></span><br><span class="line">pip install EasyProcess</span><br><span class="line">pip install xvfbwrapper</span><br><span class="line">pip install pyvirtualdisplay</span><br></pre></td></tr></table></figure><h2 id="示例脚本"><a href="#示例脚本" class="headerlink" title="示例脚本"></a>示例脚本</h2><h3 id="bing搜索"><a href="#bing搜索" class="headerlink" title="bing搜索"></a>bing搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</span><br><span class="line"><span class="comment"># 创建一个虚拟显示 </span></span><br><span class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">1280</span>, <span class="number">768</span>))</span><br><span class="line">display.start()</span><br><span class="line"><span class="comment"># 配置Firefox选项 </span></span><br><span class="line">firefox_options = Options()</span><br><span class="line">firefox_options.headless = <span class="literal">True</span> <span class="comment"># 以headless模式运行，具体代码如下：</span></span><br><span class="line"> <span class="comment"># 创建Firefox </span></span><br><span class="line">browser = webdriver.Firefox(options=firefox_options)</span><br><span class="line"><span class="comment"># 在这里编写您的代码，例如访问网页、操作元素等</span></span><br><span class="line">query = <span class="string">&#x27;Selenium的使用&#x27;</span></span><br><span class="line">url = <span class="string">f&quot;https://cn.bing.com/search?q=<span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">title = browser.title</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Page title: &quot;</span>, title)</span><br><span class="line">browser.save_screenshot(<span class="string">&#x27;screenshot1.png&#x27;</span>)</span><br><span class="line"><span class="comment"># 关闭WebDriver和虚拟显示 </span></span><br><span class="line">browser.quit()</span><br><span class="line">display.stop()</span><br></pre></td></tr></table></figure><h3 id="西交成绩更新通知"><a href="#西交成绩更新通知" class="headerlink" title="西交成绩更新通知"></a>西交成绩更新通知</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个虚拟显示 </span></span><br><span class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">1280</span>, <span class="number">768</span>))</span><br><span class="line">display.start()</span><br><span class="line"><span class="comment"># 配置选项 </span></span><br><span class="line">chrome_option = Options()</span><br><span class="line">chrome_option.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>) <span class="comment">#解决DevToolsActivePort文件不存在的报错</span></span><br><span class="line">chrome_option.headless = <span class="literal">True</span> <span class="comment"># 以headless模式运行，具体代码如下：</span></span><br><span class="line">chrome_option.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">chrome_option.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line"> <span class="comment"># 创建Chrome</span></span><br><span class="line">browser = webdriver.Chrome(chrome_option)</span><br><span class="line">browser.maximize_window()  <span class="comment"># 最大化窗口</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>) <span class="comment"># 等待加载10s</span></span><br><span class="line"><span class="comment"># 在这里编写您的代码，例如访问网页、操作元素等</span></span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">&#x27;http://gmis.xjtu.edu.cn/pyxx&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = wait.until(EC.presence_of_element_located(</span><br><span class="line">    (By.XPATH, <span class="string">&#x27;//*[@id=&quot;form1&quot;]/input[1]&#x27;</span>)))</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;学号&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = wait.until(EC.presence_of_element_located(</span><br><span class="line">    (By.XPATH, <span class="string">&#x27;//*[@id=&quot;form1&quot;]/input[2]&#x27;</span>)))</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">submit = wait.until(EC.element_to_be_clickable(</span><br><span class="line">    (By.XPATH, <span class="string">&#x27;//*[@id=&quot;account_login&quot;]&#x27;</span>)))</span><br><span class="line">submit.click() <span class="comment"># 点击登录按钮</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(browser.page_source)</span></span><br><span class="line"><span class="comment"># browser.save_screenshot(&#x27;screenshot1.png&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成绩查询页面</span></span><br><span class="line">browser.get(<span class="string">&quot;http://gmis.xjtu.edu.cn/pyxx/pygl/xscjcx/index&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># browser.page_source</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(browser.page_source, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">data_list = []  </span><br><span class="line"><span class="keyword">for</span> idx, tr <span class="keyword">in</span> <span class="built_in">enumerate</span>(soup.find_all(<span class="string">&#x27;tr&#x27;</span>)):</span><br><span class="line">    tds = tr.find_all(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> tds:</span><br><span class="line">        data_list.append(&#123;</span><br><span class="line">            <span class="string">&#x27;课程名称&#x27;</span>: tds[<span class="number">0</span>].get_text(strip=<span class="literal">True</span>),</span><br><span class="line">            <span class="string">&#x27;成绩&#x27;</span>: tds[<span class="number">3</span>].get_text(strip=<span class="literal">True</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="built_in">print</span>(data_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭WebDriver和虚拟显示 </span></span><br><span class="line">browser.quit()</span><br><span class="line">display.stop()</span><br></pre></td></tr></table></figure><p>结果:<br>[{‘课程名称’: ‘工程伦理（二）’, ‘成绩’: ‘90’}, {‘课程名称’: ‘软件能力成熟度模型’, ‘成绩’: ‘优’}, {‘课程名称’: ‘深度学习及应用’, ‘成绩’: ‘优’}, {‘课程名称’: ‘应修总学分’, ‘成绩’: ‘6.0’}, {‘课程名称’: ‘应修学位学分’, ‘成绩’: ‘2.0’}]<br>稍微有点小bug, 会将最后一个表格也识别上, 不管了, 无伤大雅<br><img src="https://oss.zaqai.com/img/202402292118609.png" alt=""><br>判断成绩更新并推送通知<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">msg</span>):</span><br><span class="line">    headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.post(<span class="string">&quot;URL&quot;</span>, json=&#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&#x27;教务监控&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: msg,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>: msg,</span><br><span class="line">        <span class="string">&quot;channel&quot;</span>:<span class="string">&quot;qiyeweixin&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.basename(sys.argv[<span class="number">0</span>])+<span class="string">&#x27;_output.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 读取文件的内容</span></span><br><span class="line">    file_content = file.read()</span><br><span class="line"><span class="comment"># Open a file for writing</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.basename(sys.argv[<span class="number">0</span>])+<span class="string">&#x27;_output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(<span class="built_in">str</span>(data_list))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(file_content)!=<span class="built_in">str</span>(data_list):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出新成绩了&quot;</span>)</span><br><span class="line">    push(<span class="built_in">str</span>(data_list))</span><br></pre></td></tr></table></figure></p><h2 id="开箱即用-Docker容器"><a href="#开箱即用-Docker容器" class="headerlink" title="开箱即用-Docker容器"></a>开箱即用-Docker容器</h2><p><a href="https://github.com/SeleniumHQ/docker-selenium">SeleniumHQ/docker-selenium: Provides a simple way to run Selenium Grid with Chrome, Firefox, and Edge using Docker, making it easier to perform browser automation (github.com)</a>提供了很多Selenium的Docker镜像。</p><p>推荐<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --name chrome-debug -h chrome-debug --memory 2g --memory-swap -1 -p 9516:4444 -p 31527:5900 selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure><br>在这里可以看到session会话 <a href="http://ip:9516/wd/hub/static/resource/hub.html">http://ip:9516/wd/hub/static/resource/hub.html</a><br><img src="https://oss.zaqai.com/img/202403052207690.png" alt=""><br>好处是提供了一个vnc server, 端口31527, 可以看到浏览器的界面<br><img src="https://oss.zaqai.com/img/202403052209297.png" alt=""></p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程Docker服务的地址和端口</span></span><br><span class="line"><span class="comment">#wd 表示 WebDriver，hub 表示服务器的入口点。</span></span><br><span class="line"><span class="comment">#通过在 URL 中指定 /wd/hub，您告诉 Selenium 客户端要连接到远程的 WebDriver 服务器</span></span><br><span class="line"><span class="comment">#服务器9516映射到docker中4444端口也就是Webdriver-selenim服务端口</span></span><br><span class="line">remote_url = <span class="string">&#x27;http://ip:9516/wd/hub&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置浏览器选项</span></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到远程Selenium Chrome节点</span></span><br><span class="line">driver = webdriver.Remote(command_executor=remote_url, options=chrome_options)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux无图形界面使用selenium自动登录爬取数据&quot;&gt;&lt;a href=&quot;#linux无图形界面使用selenium自动登录爬取数据&quot; class=&quot;headerlink&quot; title=&quot;linux无图形界面使用selenium自动登录爬取数据&quot;&gt;&lt;/a&gt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux小技巧备忘</title>
    <link href="https://blog.zaqai.com/2024/01/31/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"/>
    <id>https://blog.zaqai.com/2024/01/31/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/</id>
    <published>2024-01-30T23:18:03.178Z</published>
    <updated>2024-01-31T15:07:31.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux小技巧备忘"><a href="#linux小技巧备忘" class="headerlink" title="linux小技巧备忘"></a>linux小技巧备忘</h1><h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><ul><li><p><code>bash -x test.sh</code>可以看到脚本执行情况, 类似边debug边执行</p></li><li><p>可以使用<code>echo $?</code>查看上条命令返回值, 0表示成功, 非0失败</p></li><li><p>if 语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="variable">$COUNT</span> -eq 3]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> hhh</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">---</span><br><span class="line"><span class="comment"># 可以是其他command, 执行成功, 判断为真, 否则为假</span></span><br><span class="line"><span class="keyword">if</span> ping -c 1 baidu.com; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> hhh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>for</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)); <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> hhh</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">---</span><br><span class="line">IP_LIST=<span class="string">&quot;127.0.0.1 172.17.0.1 1.1.1.1&quot;</span></span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$IP_LIST</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> hhh</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="linux三剑客"><a href="#linux三剑客" class="headerlink" title="linux三剑客"></a>linux三剑客</h2><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则匹配以`/dev`开头的行, 并打印第1 5列</span></span><br><span class="line"><span class="built_in">df</span> -h | awk <span class="string">&#x27;/^\/dev/&#123;print $1,$5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 选择第2行, 并打印最后一列</span></span><br><span class="line">free -m | awk <span class="string">&#x27;NR==2&#123;print $NF&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul><li><code>curl -Ls google.com -w &quot;%&#123;http_code&#125;&quot; -o /dev/null</code>只输出状态码, 不能<code>&gt;/dev/null</code>, 会把状态码也给重定向了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux小技巧备忘&quot;&gt;&lt;a href=&quot;#linux小技巧备忘&quot; class=&quot;headerlink&quot; title=&quot;linux小技巧备忘&quot;&gt;&lt;/a&gt;linux小技巧备忘&lt;/h1&gt;&lt;h2 id=&quot;shell脚本&quot;&gt;&lt;a href=&quot;#shell脚本&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据实验报告</title>
    <link href="https://blog.zaqai.com/2024/01/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://blog.zaqai.com/2024/01/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2024-01-18T20:18:03.178Z</published>
    <updated>2024-01-18T13:02:05.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据实验报告"><a href="#大数据实验报告" class="headerlink" title="大数据实验报告"></a>大数据实验报告</h1><p>[toc]</p><h2 id="2-HDFS-分布式文件系统实战"><a href="#2-HDFS-分布式文件系统实战" class="headerlink" title="2 HDFS 分布式文件系统实战"></a>2 HDFS 分布式文件系统实战</h2><h3 id="任务一：HDFS-常用操作"><a href="#任务一：HDFS-常用操作" class="headerlink" title="任务一：HDFS 常用操作"></a>任务一：HDFS 常用操作</h3><ul><li><p>步骤 1 help 命令</p><p><img src="https://oss.zaqai.com/img/202401181543169.png" alt="image-20240118154306943" style="zoom:67%;" /></p></li></ul><p>  <img src="https://oss.zaqai.com/img/202401181543325.png" alt="image-20240118154359249" style="zoom:67%;" /></p><ul><li><p>步骤 2 ls 命令</p><p><img src="https://oss.zaqai.com/img/202401181544721.png" alt="image-20240118154448647" style="zoom:67%;" /></p></li><li><p>步骤 3 mkdir 命令</p><p><img src="https://oss.zaqai.com/img/202401181546204.png" alt="image-20240118154615154" style="zoom:67%;" /></p></li><li><p>步骤 4 put 命令</p><p><img src="https://oss.zaqai.com/img/202401181548784.png" alt="image-20240118154830727" style="zoom:67%;" /></p></li><li><p>步骤 5 cat 命令</p><p><img src="https://oss.zaqai.com/img/202401181549527.png" alt="image-20240118154911490" style="zoom:67%;" /></p></li><li><p>步骤 6 text 命令</p><p><img src="https://oss.zaqai.com/img/202401181549664.png" alt="image-20240118154954624" style="zoom:67%;" /></p></li><li><p>步骤 7 moveFromLocal 命令</p><p><img src="https://oss.zaqai.com/img/202401181552583.png" alt="image-20240118155237523" style="zoom:67%;" /></p></li><li><p>步骤 8 appendToFile 命令</p><p><img src="https://oss.zaqai.com/img/202401181554295.png" alt="image-20240118155421252" style="zoom:67%;" /></p></li><li><p>步骤 9 cp 命令</p><p><img src="https://oss.zaqai.com/img/202401181556291.png" alt="image-20240118155650208" style="zoom:67%;" /></p></li><li><p>步骤 10 mv 命令</p><p><img src="https://oss.zaqai.com/img/202401181559942.png" alt="image-20240118155906818" style="zoom:67%;" /></p></li><li><p>步骤 11 get 命令</p><p><img src="https://oss.zaqai.com/img/202401181601462.png" alt="image-20240118160103406" style="zoom:67%;" /></p></li><li><p>步骤 12 getmerge 命令</p><p><img src="https://oss.zaqai.com/img/202401181602357.png" alt="image-20240118160251290" style="zoom:67%;" /></p></li><li><p>步骤 13 rm 命令</p><p><img src="https://oss.zaqai.com/img/202401181603693.png" alt="image-20240118160347639" style="zoom:67%;" /></p></li><li><p>步骤 14 df 命令  步骤 15 du 命令  步骤 16 count 命令</p><p><img src="https://oss.zaqai.com/img/202401181606948.png" alt="image-20240118160605898" style="zoom:67%;" /></p></li></ul><h3 id="任务二：回收站使用"><a href="#任务二：回收站使用" class="headerlink" title="任务二：回收站使用"></a>任务二：回收站使用</h3><p><img src="https://oss.zaqai.com/img/202401181608686.png" alt="image-20240118160812604" style="zoom:67%;" /></p><h2 id="4-Hbase-列式数据库实战"><a href="#4-Hbase-列式数据库实战" class="headerlink" title="4 Hbase 列式数据库实战"></a>4 Hbase 列式数据库实战</h2><h3 id="任务一：HBase-常用操作"><a href="#任务一：HBase-常用操作" class="headerlink" title="任务一：HBase 常用操作"></a>任务一：HBase 常用操作</h3><ul><li><p>创建普通表</p><p><img src="https://oss.zaqai.com/img/202401182026150.png" alt="image-20240118202624091" style="zoom:67%;" /></p></li><li><p>增加数据  Scan 方式查询数据   Get 方式查询数据  指定条件查询数据</p><p><img src="https://oss.zaqai.com/img/202401182030861.png" alt="image-20240118203008780" style="zoom:67%;" /></p></li><li><p>查询多版本数据</p><p><img src="https://oss.zaqai.com/img/202401182034889.png" alt="image-20240118203440729" style="zoom:67%;" /></p></li><li><p>删除数据</p><p><img src="https://oss.zaqai.com/img/202401182037915.png" alt="image-20240118203748828" style="zoom:67%;" /></p></li><li><p>删除表</p><p><img src="https://oss.zaqai.com/img/202401182038035.png" alt="image-20240118203857967" style="zoom:67%;" /></p></li></ul><h3 id="任务二：创建预分-region-表"><a href="#任务二：创建预分-region-表" class="headerlink" title="任务二：创建预分 region 表"></a>任务二：创建预分 region 表</h3><ul><li><p>以 rowkey 切分，随机分为 4 个 region</p><p><img src="https://oss.zaqai.com/img/202401182040242.png" alt="image-20240118204018193" style="zoom:67%;" /></p></li></ul><p>  <img src="https://oss.zaqai.com/img/202401182042915.png" alt="image-20240118204203837" style="zoom:67%;" /></p><ul><li><p>指定 region 的 startKey 和 endKey</p><p><img src="https://oss.zaqai.com/img/202401182044701.png" alt="image-20240118204412595" style="zoom:67%;" /></p></li></ul><h3 id="任务三：Filter-过滤器使用"><a href="#任务三：Filter-过滤器使用" class="headerlink" title="任务三：Filter 过滤器使用"></a>任务三：Filter 过滤器使用</h3><p><img src="https://oss.zaqai.com/img/202401182047129.png" alt="image-20240118204749041" style="zoom:67%;" /></p><h2 id="5-MarpReduce-数据处理实战"><a href="#5-MarpReduce-数据处理实战" class="headerlink" title="5 MarpReduce 数据处理实战"></a>5 MarpReduce 数据处理实战</h2><ul><li><p>步骤 3 上传文件到 HDFS 系统  步骤 4 执行 jar 包程序</p><p><img src="https://oss.zaqai.com/img/202401181617805.png" alt="image-20240118161741667" style="zoom:67%;" /></p></li><li><p>步骤 5 查看统计结果</p><p><img src="https://oss.zaqai.com/img/202401181619049.png" alt="image-20240118161922981" style="zoom:67%;" /></p></li></ul><h2 id="8-Kafka-消息订阅实战"><a href="#8-Kafka-消息订阅实战" class="headerlink" title="8 Kafka 消息订阅实战"></a>8 Kafka 消息订阅实战</h2><h3 id="任务一：shell-端-Kafka-消息的生产、消费。"><a href="#任务一：shell-端-Kafka-消息的生产、消费。" class="headerlink" title="任务一：shell 端 Kafka 消息的生产、消费。"></a>任务一：shell 端 Kafka 消息的生产、消费。</h3><ul><li><p>步骤 2 创建 Kafka 主题  步骤 3 查看 topic</p><p><img src="https://oss.zaqai.com/img/202401181706753.png" alt="image-20240118170659679"></p></li><li><p>步骤 4 创建 console 消费者</p><p><img src="https://oss.zaqai.com/img/202401181714011.png" alt="image-20240118171434960"></p></li></ul><ul><li><p>步骤 5 创建 console 生产者</p><p><img src="https://oss.zaqai.com/img/202401181713978.png" alt="image-20240118171346911"></p></li><li><p>步骤 6 测试生产者、消费者</p><p><img src="https://oss.zaqai.com/img/202401181713087.png" alt="image-20240118171325040"></p></li></ul><h3 id="任务二：Kafka-多消费者之消费组"><a href="#任务二：Kafka-多消费者之消费组" class="headerlink" title="任务二：Kafka 多消费者之消费组"></a>任务二：Kafka 多消费者之消费组</h3><ul><li><p>步骤 1 创建主题</p><p><img src="https://oss.zaqai.com/img/202401181722270.png" alt="image-20240118172219199"></p></li><li><p>步骤 2 创建生产者和消费者</p><p><img src="https://oss.zaqai.com/img/202401181723852.png" alt="image-20240118172314790"></p></li></ul><p>  <img src="https://oss.zaqai.com/img/202401181724467.png" alt="image-20240118172407405"></p><ul><li><p>步骤 3 设置三个消费者</p><p><img src="https://oss.zaqai.com/img/202401181727844.png" alt="image-20240118172724708" style="zoom:67%;" /></p></li><li><p>步骤 4 启动第四个消费者</p><p><img src="https://oss.zaqai.com/img/202401181729937.png" alt="image-20240118172929899" style="zoom:67%;" /></p></li><li><p>步骤 5 设置四个消费者</p><p><img src="https://oss.zaqai.com/img/202401181734038.png" alt="image-20240118173452974" style="zoom:67%;" /></p></li><li><p>步骤 6 设置两个消费者</p><p><img src="https://oss.zaqai.com/img/202401181737526.png" alt="image-20240118173738473" style="zoom:67%;" /></p><p><img src="https://oss.zaqai.com/img/202401181739200.png" alt="image-20240118173946107"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大数据实验报告&quot;&gt;&lt;a href=&quot;#大数据实验报告&quot; class=&quot;headerlink&quot; title=&quot;大数据实验报告&quot;&gt;&lt;/a&gt;大数据实验报告&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;2-HDFS-分布式文件系统实战&quot;&gt;&lt;a href=&quot;#2-HD</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>无root配置科研环境</title>
    <link href="https://blog.zaqai.com/2024/01/16/%E6%97%A0root%E9%85%8D%E7%BD%AE%E7%A7%91%E7%A0%94%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.zaqai.com/2024/01/16/%E6%97%A0root%E9%85%8D%E7%BD%AE%E7%A7%91%E7%A0%94%E7%8E%AF%E5%A2%83/</id>
    <published>2024-01-15T20:18:03.287Z</published>
    <updated>2024-04-17T14:26:07.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无root配置科研环境"><a href="#无root配置科研环境" class="headerlink" title="无root配置科研环境"></a>无root配置科研环境</h1><h2 id="安装ohmyzsh"><a href="#安装ohmyzsh" class="headerlink" title="安装ohmyzsh"></a>安装ohmyzsh</h2><p>首先检查有没有zsh，并没有，先安装zsh</p><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget -O zsh.tar.xz https://sourceforge.net/projects/zsh/files/latest/download --no-check-certificate</span><br><span class="line"><span class="built_in">mkdir</span> zsh &amp;&amp; unxz zsh.tar.xz &amp;&amp; tar -xvf zsh.tar -C zsh --strip-components 1</span><br><span class="line"><span class="comment"># 可以尝试直接编译安装,但大概率报错</span></span><br><span class="line"><span class="built_in">cd</span> zsh</span><br><span class="line"><span class="comment"># 编译zsh</span></span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/app/zsh</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 安装完成后。加入环境变量.bashrc</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/app/zsh/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>执行./configure的时候应该就会报错, 报错的话就先编译安装ncurses吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-6.0.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> ncurses</span><br><span class="line">tar -xvf ncurses-6.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> ncurses-6.0</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/app/ncurses --with-shared --without-debug --enable-widec</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>大概率还是会报错<code>../include/curses.h:1943:56: note: in definition of macro ‘mouse_trafo’</code><br>但要修改的是<code>include/curses.tail</code>文件, 好像是因为<code>curses.h</code>里面的代码是由<code>curses.tail</code>导入的</p><p>删除这里的注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">103</span> <span class="keyword">extern</span> <span class="title function_">NCURSES_EXPORT</span><span class="params">(<span class="type">bool</span>)</span>    <span class="title function_">wmouse_trafo</span> <span class="params">(<span class="type">const</span> WINDOW*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">bool</span>)</span>;</span><br><span class="line"><span class="number">104</span> <span class="keyword">extern</span> <span class="title function_">NCURSES_EXPORT</span><span class="params">(<span class="type">bool</span>)</span>    <span class="title function_">mouse_trafo</span> <span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">bool</span>)</span>;   <span class="comment">/* generated */</span></span><br></pre></td></tr></table></figure><p>再<code>make clean &amp;&amp; make &amp;&amp; make install</code>就可以安装ncurses成功</p><p>配置ncurses环境变量在<code>.bashrc</code>中, 并<code>source</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CXXFLAGS=<span class="string">&quot;-fPIC&quot;</span></span><br><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">&quot;-fPIC&quot;</span></span><br><span class="line"><span class="built_in">export</span> NCURSES_HOME=<span class="variable">$HOME</span>/app/ncurses  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NCURSES_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$NCURSES_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I<span class="variable">$NCURSES_HOME</span>/include&quot;</span> LDFLAGS=<span class="string">&quot;-L<span class="variable">$NCURSES_HOME</span>/lib&quot;</span></span><br></pre></td></tr></table></figure><p>再执行安装zsh的<code>./configure</code>之后的命令就可以成功安装zsh</p><p>在<code>.profile</code>里加入<code>[ -f $HOME/app/zsh/bin/zsh ] &amp;&amp; exec $HOME/app/zsh/bin/zsh -l</code>就可以登陆就是zsh了</p><h3 id="安装ohmyzsh-1"><a href="#安装ohmyzsh-1" class="headerlink" title="安装ohmyzsh"></a>安装ohmyzsh</h3><p>还是手动安装吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line"><span class="built_in">cp</span> ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting --depth=1</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions --depth=1</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-completions --depth=1</span><br><span class="line"><span class="comment"># 修改.zshrc</span></span><br><span class="line">plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions)</span><br></pre></td></tr></table></figure><p>安装fzf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="安装anaconda"><a href="#安装anaconda" class="headerlink" title="安装anaconda"></a>安装anaconda</h2><p><code>zsh Anaconda3-2023.09-0-Linux-x86_64.sh</code>默认+yes</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;无root配置科研环境&quot;&gt;&lt;a href=&quot;#无root配置科研环境&quot; class=&quot;headerlink&quot; title=&quot;无root配置科研环境&quot;&gt;&lt;/a&gt;无root配置科研环境&lt;/h1&gt;&lt;h2 id=&quot;安装ohmyzsh&quot;&gt;&lt;a href=&quot;#安装ohmyzs</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>zero-shot object counting论文阅读1</title>
    <link href="https://blog.zaqai.com/2024/01/11/zero-shot%20object%20counting%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/"/>
    <id>https://blog.zaqai.com/2024/01/11/zero-shot%20object%20counting%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/</id>
    <published>2024-01-10T20:18:03.287Z</published>
    <updated>2024-01-11T11:11:56.903Z</updated>
    
    <content type="html"><![CDATA[<h1>VLCounter: Text-aware Visual Representation for Zero-Shot Object Counting</h1><blockquote><p>AAAI2024</p><p><a href="https://github.com/seunggu0305/VLCounter">https://github.com/seunggu0305/VLCounter</a></p><p>- zero-shot</p><p>- 视觉语言模型</p><p>- 在FSC-147上比clip-count的MAE低了零点几</p></blockquote><h2 id="1-Visual-Language-Base">1. Visual-Language Base</h2><p><img src="https://oss.zaqai.com/img/202401101716411.png" alt="image-20240110171630302"></p><p><img src="https://math.now.sh?inline=S_%7Bi%20j%7D%28%5Cmathcal%7BV%7D%2C%5Cmathcal%7BT%7D%29%3D%5Cfrac%7Bv_%7Bi%20j%7D%5Cmathcal%7BT%7D%5ET%7D%7B%7C%7Cv_%7Bi%20j%7D%7C%7C%7C%5Cmathcal%7BT%7D%7C%7C%7D" style="display:inline-block;margin: 0;"/></p><p>T: 语义嵌入向量  V: 块嵌入向量  S: 相似度图</p><p>S表示图像块和文本的相似度程度，可以帮助解码器定位目标。</p><p><img src="https://math.now.sh?inline=%7B%5Ccal%20D%7D_%7B%5Cmathrm%7Bpred%7D%7D%3D%5Cphi_%7B%5Cmathrm%7Bdecoder%7D%7D%28%5B%5Cnu%2CS%5D%29" style="display:inline-block;margin: 0;"/>        <img src="https://math.now.sh?inline=%7B%5Cmathcal%7BL%7D%7D_%7B%5Cmathrm%7Bcount%7D%7D%3D%7C%7CD_%7B%5Cmathrm%7Bpred%7D%7D-D_%7B%5Cmathrm%7Bgt%7D%7D%7C%7C_%7B2%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p><h2 id="2-Visual-Language-Counter">2. Visual-Language Counter</h2><h3 id="2-1-语义条件下的提示微调-SPT">2.1 语义条件下的提示微调 (SPT)</h3><p><img src="https://oss.zaqai.com/img/202401101718391.png" alt="image-20240110171841346"></p><p><img src="https://math.now.sh?inline=%5Chat%7B%5Cmathcal%7BP%7D%7D%5El%3D%5Bp_1%5El%2B%5Chat%7B%5Cmathcal%7BT%7D%7D%2Cp_2%5El%2B%5Chat%7B%5Cmathcal%7BT%7D%7D%2Cp_M%5El%2B%5Chat%7B%5Cmathcal%7BT%7D%7D%5D%2C" style="display:inline-block;margin: 0;"/>        <img src="https://math.now.sh?inline=%5B%5Bcls%5D%2C%5C_%2C%5Cmathcal%7BV%7D%5E%7Bl%2B1%7D%5D%3DLayer_%7B%5Cmathrm%7Benc%7D%7D%5E%7Bl%7D%28%5B%5Bcls%5D%2C%5Chat%7B%5Cmathcal%7BP%7D%7D%5E%7Bl%7D%2C%5Cmathcal%7BV%7D%5E%7Bl%7D%5D%29%2C" style="display:inline-block;margin: 0;"/></p><p>目的是突出显示相应区域的目标</p><h3 id="2-2-可学习的仿射变换-LAT">2.2 可学习的仿射变换 (LAT)</h3><p>由于物体计数的目标是找到物体的中心点而不是整个物体区域，相似图S中包含的信息与训练期间需要回传的损失之间可能会存在差异。</p><p>通过将S变换为<img src="https://math.now.sh?inline=%5Chat%7BS%7D" style="display:inline-block;margin: 0;"/>, 围绕单独的物体建立更加任务相关的视觉语义关联</p><p><img src="https://math.now.sh?inline=%5Chat%7BS%7D%3DW%5Cotimes%20S%2BB" style="display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7DW%2CB%5Cin%26%5Cmathbb%7BR%7D%5E%7BH%5Ctimes%20W%7D%5Cend%7Baligned%7D" style="display:inline-block;margin: 0;"/> 是可学习的矩阵，使用排名感知对比损失直接优化计数图<img src="https://math.now.sh?inline=%5Chat%7BS%7D" style="display:inline-block;margin: 0;"/>，以学习对象计数的正确激活度。</p><p><img src="https://oss.zaqai.com/img/202401111845237.png" alt="image-20240111184514037"></p><p>突出显示包含目标的区域，抑制不包含目标的区域</p><h3 id="2-3-分段感知跳跃连接-SaSC">2.3 分段感知跳跃连接(SaSC)</h3><p><img src="https://oss.zaqai.com/img/202401101743386.png" alt="image-20240110172423790"></p><p>为了使用CLIP特征中保留的局部语义信息, 采用跳跃连接, 将图片编码器的中间特征混合到解码器的对应层中, 保证模型对没有见过的类别的泛化能力</p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BF%7D%5Ek%3DLayer_%7B%5Cmathrm%7Bdec%7D%7D%5Ek%28%5Cmathcal%7BF%7D%5E%7Bk-1%7D%2B%5Cphi_%7B%5Cmathrm%7Bproj%7D%7D%5Ek(%5Cmathcal%7BV%7D%5El%29%5Cotimes%5Chat%7BS%7D)%2C" style="display:inline-block;margin: 0;"/></p><h3 id="2-4-损失函数">2.4 损失函数</h3><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%5Cmathrm%7Bcount%7D" style="display:inline-block;margin: 0;"/>训练整个模型以学习计数目标，但在SPT和LAT中的重点是学习生成针对计数的相似性映射, 所以采用排名感知对比损失来优化<img src="https://math.now.sh?inline=%5Chat%7BS%7D" style="display:inline-block;margin: 0;"/>，将对象中心附近的图像块赋予更高激活度。</p><p>将真实密度图标准化为在0和1之间映射的值, 来确定正负样本</p><p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D_%7B%5Cmathrm%7Brank%7D%7D%3D-%5Csum_%7Bk%3D1%7D%5EK%5Clog%5Cfrac%7B%5Csum_%7B%5Chat%7BS%7D_i%5Cin%5Chat%7BS%7D_r%5E%7B%5Cmathrm%7Bpos%7D%7D%7D%5Cexp%28%5Chat%7BS%7D_i%2F%5Ctau%29%7D%7B%5Csum_%7B%5Chat%7BS%7D_j%5Cin(%5Chat%7BS%7D_r%5E%7B%5Cmathrm%7Bpos%7D%7D%5Ccup%5Chat%7BS%7D_r%5E%7B%5Cmathrm%7Bneg%7D%7D)%7D%5Cexp(%5Chat%7BS%7D_j%2F%5Ctau)%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D_%5Cmathrm%7Btotal%7D%3D%5Cmathcal%7BL%7D_%5Cmathrm%7Bcount%7D%2B%5Clambda%5Ccdot%5Cmathcal%7BL%7D_%5Cmathrm%7Brank%7D%2C" style="display:inline-block;margin: 0;"/></p><h2 id="3-性能">3. 性能</h2><p><img src="https://oss.zaqai.com/img/202401111358937.png" alt="image-20240111135824879"></p><h2 id="4-消融实验">4. 消融实验</h2><p><img src="https://oss.zaqai.com/img/202401111217610.png" alt="image-20240111121740530"></p><p>M1就是VLBase，M5是VLCounter</p><p>M2加入语义条件下的提示微调后，MAE降低很多，表明了与语义条件相结合微调的重要性</p><p>M4加入分段感知跳跃连接，表明CLIP编码器中的分层中间表示在语义上也是有意义的存在。</p><p><img src="https://oss.zaqai.com/img/202401111228593.png" alt="image-20240111122805557"></p><p>在VPT中使用语义条件T可以使得提示更加语义特定</p><p>使用计数图S的语义条件可以抑制与对象无关的信息</p><p><img src="https://oss.zaqai.com/img/202401111231691.png" alt="image-20240111123106660"></p><p>由于计数任务主要假设每张图像中存在多个实例，将文本提示修改为复数形式也可以提高性能</p><h2 id="5-对比CLIP-count">5. 对比CLIP-count</h2><p><img src="https://oss.zaqai.com/img/202401111356269.png" alt="image-20240111135604226"></p><p><img src="https://oss.zaqai.com/img/202401111356237.png" alt="image-20240111135642203"></p><hr><h1>Open-world Text-specified Object Counting</h1><blockquote><p>BMVC 2023</p><p><a href="https://github.com/niki-amini-naieni/CounTX/">https://github.com/niki-amini-naieni/CounTX/</a></p><p>端到端的单阶段开放类别物体计数模型</p><p>zero-shot</p></blockquote><h2 id="1-CounTX">1. CounTX</h2><p><img src="https://oss.zaqai.com/img/202401111500952.png" alt="image-20240111150040892"></p><p>图像编码器: CLIP ViT-B-16(16x16的块尺寸, 12层, 最终嵌入向量维度是512), 没有用到输出的分类向量</p><p>文本编码器: CLIP ViT-B-16(context length是77, 12层, 最终嵌入向量维度是512)</p><p>特征交互模块: 使用了两个Transformer解码器层, 图像块特征作为query, 文本特征作为K和V, 来建模图像和文本的相似性</p><p>解码器: fϕ的输出被重塑成具有512通道的空间特征图。每个通道使用双线性插值放大到24×24像素。然后，通过具有256个滤波器的卷积层进行上采样，将其高度和宽度增加两倍, 操作做4次。将特征图的尺寸变为和输入图像一样, 但是有256个通道。这些通道使用一个1×1卷积组合成一个单通道密度图。该密度图通过求和来估计物体数量。</p><p>损失函数: <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%28%5Chat%7BY%7D%2CY%29%3D%5Cfrac1%7BH%5Ctimes%20W%7D%5Csum_%7Bp%2Cq%7D((%5Chat%7BY%7D)_%7Bp%2Cq%7D-(Y)_%7Bp%2Cq%7D)%5E2" style="display:inline-block;margin: 0;"/></p><h2 id="2-FSC-147-D">2.  FSC-147-D</h2><p><img src="https://oss.zaqai.com/img/202401111625149.png" alt="image-20240111162516997"></p><p>FSC-147的增强版本，对类别描述做了修正或更加详细的描述</p><p>大部分只是在原始类别名称前加了&quot;the&quot;, 少部分做了修正或更加详细的描述</p><h2 id="3-性能-2">3. 性能</h2><p><img src="https://oss.zaqai.com/img/202401111628324.png" alt="image-20240111162835284"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;VLCounter: Text-aware Visual Representation for Zero-Shot Object Counting&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;AAAI2024&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过RSSHub订阅学院通知</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E9%80%9A%E8%BF%87RSSHub%E8%AE%A2%E9%98%85%E5%AD%A6%E9%99%A2%E9%80%9A%E7%9F%A5/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E9%80%9A%E8%BF%87RSSHub%E8%AE%A2%E9%98%85%E5%AD%A6%E9%99%A2%E9%80%9A%E7%9F%A5/</id>
    <published>2023-12-31T20:18:03.330Z</published>
    <updated>2023-12-31T12:19:56.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过RSSHub订阅学院通知"><a href="#通过RSSHub订阅学院通知" class="headerlink" title="通过RSSHub订阅学院通知"></a>通过RSSHub订阅学院通知</h1><blockquote><p>今天看到以为up主在介绍RSSHub, 遂入坑, 上午在了解RSS, 并搭建了RSSHub, 下午费了九牛二虎之力终于给学院写了个RSS订阅(只怪自己js学的不够通透)</p><p><a href="https://www.bilibili.com/video/BV1pT4y1y7AH">【干货分享】三分钟教你部署RSSHub!_哔哩哔哩_bilibili</a></p></blockquote><p><a href="http://ssdut.dlut.edu.cn/">大连理工大学软件学院(新) (dlut.edu.cn)</a>RSS订阅地址: <a href="https://rss.zaqai.com/ssdut">https://rss.zaqai.com/ssdut</a></p><p>路由: 默认是本科生通知, 即<a href="https://rss.zaqai.com/ssdut%E5%92%8Chttps://rss.zaqai.com/ssdut/bkstz%E7%AD%89%E4%BB%B7">https://rss.zaqai.com/ssdut和https://rss.zaqai.com/ssdut/bkstz等价</a>, 对应于<a href="http://ssdut.dlut.edu.cn/index/bkstz.htm">本科生通知-大连理工大学软件学院(新) (dlut.edu.cn)</a></p><p>还有学院通知: <a href="https://rss.zaqai.com/ssdut/xytz">https://rss.zaqai.com/ssdut/xytz</a>, 对应于<a href="http://ssdut.dlut.edu.cn/index/xytz.htm">学院通知-大连理工大学软件学院(新) (dlut.edu.cn)</a></p><p>其他的通知对我来说用处不大, 所以没有适配, 大体上差不多, 只需要更改一些jquery选择器的东西</p><h2 id="RSSHub介绍"><a href="#RSSHub介绍" class="headerlink" title="RSSHub介绍"></a>RSSHub介绍</h2><p><img src="https://oss.zaqai.com/img/image-20220222171045161.png" alt="image-20220222171045161"></p><blockquote><p>万物皆可RSS, 其实就是给你提供一个大体框架, 具体爬取哪些元素要你自己写</p><p>原理就是当你访问RSSHub, 它会根据路由去请求指定的资源, 并转换为RSS格式</p></blockquote><h2 id="RSSHub搭建"><a href="#RSSHub搭建" class="headerlink" title="RSSHub搭建"></a>RSSHub搭建</h2><p><a href="https://docs.rsshub.app/install/#shou-dong-bu-shu">部署 | RSSHub</a>讲的很详细了, 虽然有服务器, 不过我还是推荐Vercel托管(我看的视频就是讲这个的), 直接域名cname到它提供的域名就行了. 但是有一点, github仓库里的代码改了之后, 它会自动重新部署, 但是好像并没有改变.</p><h2 id="为没有适配RSS的网站适配RSS"><a href="#为没有适配RSS的网站适配RSS" class="headerlink" title="为没有适配RSS的网站适配RSS"></a>为没有适配RSS的网站适配RSS</h2><blockquote><p> 参考: <a href="https://maronyea.me/restless/72/">为任意网站创建 RSSHub 路由的思路 | Maron的自留地 (maronyea.me)</a></p></blockquote><p>只需修改两个文件: </p><ul><li><p>RSSHub目录\lib\router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大连理工大学</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/dut/:subsite/:type&#x27;</span>, <span class="title function_">lazyloadRouteHandler</span>(<span class="string">&#x27;./routes/universities/dut/index&#x27;</span>));</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/ssdut/:type?&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./routes/universities/dut/ssdut&#x27;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>增加一个ssdut的路由, :type?为可选参数</p></blockquote></li><li><p>RSSHub目录\lib\routes\universities\dut\ssdut.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> got = <span class="built_in">require</span>(<span class="string">&#x27;@/utils/got&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 域名</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;http://ssdut.dlut.edu.cn&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 分类</span></span><br><span class="line"><span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="attr">bkstz</span>: <span class="string">&#x27;/index/bkstz.htm&#x27;</span>,</span><br><span class="line">    <span class="attr">xytz</span>: <span class="string">&#x27;/index/xytz.htm&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里获取到传入的参数，也就是 /ncu/jwc/:type? 中的 type</span></span><br><span class="line">    <span class="comment">// 通过 || 来实现设置一个默认值</span></span><br><span class="line">    <span class="keyword">const</span> type = ctx.<span class="property">params</span>.<span class="property">type</span> || <span class="string">&#x27;bkstz&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 要抓取的网址</span></span><br><span class="line">    <span class="keyword">const</span> link = host + map[type] ;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取列表页，也就是发出请求，来获得这个文章列表页</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">got</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,    <span class="comment">// 请求的方法是 get，这里一般都是 get</span></span><br><span class="line">        <span class="attr">url</span>: link,        <span class="comment">// 请求的链接，也就是文章列表页</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 cheerio 来把请求回来的数据转成 DOM，方便操作</span></span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(response.<span class="property">data</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 提取列表项</span></span><br><span class="line">    <span class="keyword">const</span> urlList = $(<span class="string">&#x27;.c_hzjl_list1&#x27;</span>)    <span class="comment">// 筛选出所有 class=&quot;.c_hzjl_list1&quot; 的内容</span></span><br><span class="line">        .<span class="title function_">find</span>(<span class="string">&#x27;a&#x27;</span>)                <span class="comment">// 找到所有 &lt;a&gt; 标签，也就是文章的链接</span></span><br><span class="line">        .<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">20</span>)             <span class="comment">// 获取 10 个，也可以把它调大一点，比如 15 个。最大的个数要看这个网页中有多少条</span></span><br><span class="line">        .<span class="title function_">map</span>(<span class="function">(<span class="params">i, e</span>) =&gt;</span> $(e).<span class="title function_">attr</span>(<span class="string">&#x27;href&#x27;</span>))    <span class="comment">// 作为键值对来存储 &lt;a&gt; 标签们的 href 属性</span></span><br><span class="line">        .<span class="title function_">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要输出的文章内容保存到 out 中</span></span><br><span class="line">    <span class="keyword">const</span> out = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">        <span class="comment">// 抓取操作放这里</span></span><br><span class="line">        urlList.<span class="title function_">map</span>(<span class="keyword">async</span> (itemUrl) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取文章的完整链接</span></span><br><span class="line">            itemUrl = url.<span class="title function_">resolve</span>(host+map[type] , itemUrl);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这里是使用 RSSHub 的缓存机制</span></span><br><span class="line">            <span class="keyword">const</span> cache = <span class="keyword">await</span> ctx.<span class="property">cache</span>.<span class="title function_">get</span>(itemUrl);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(cache));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取列表项中的网页</span></span><br><span class="line">            <span class="keyword">const</span> response = <span class="keyword">await</span> got.<span class="title function_">get</span>(itemUrl);</span><br><span class="line">            <span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(response.<span class="property">data</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// single 就是一篇文章了，里面包括了标题、链接、内容和时间</span></span><br><span class="line">            <span class="keyword">const</span> single = &#123;</span><br><span class="line">                <span class="attr">title</span>: $(<span class="string">&#x27;title&#x27;</span>).<span class="title function_">text</span>(),      <span class="comment">// 提取标题</span></span><br><span class="line">                <span class="attr">link</span>: itemUrl,                 <span class="comment">// 文章链接</span></span><br><span class="line">                <span class="attr">description</span>: $(<span class="string">&#x27;.v_news_content&#x27;</span>)        <span class="comment">// 文章内容，并且用了个将文章的链接和图片转成完整路径的 replace() 方法</span></span><br><span class="line">                    .<span class="title function_">html</span>()</span><br><span class="line">                    .<span class="title function_">replace</span>(<span class="regexp">/src=&quot;\//g</span>, <span class="string">`src=&quot;<span class="subst">$&#123;url.resolve(host, <span class="string">&#x27;.&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">                    .<span class="title function_">replace</span>(<span class="regexp">/href=&quot;\//g</span>, <span class="string">`href=&quot;<span class="subst">$&#123;url.resolve(host, <span class="string">&#x27;.&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">                    .<span class="title function_">trim</span>(),</span><br><span class="line">                <span class="attr">pubDate</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(</span><br><span class="line">                        $(<span class="string">&#x27;.mt_15, .mb_15, .mt_10, .mb_10&#x27;</span>)</span><br><span class="line">                        .<span class="title function_">text</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[1-9][0-9]&#123;3&#125;年[0-9]&#123;2&#125;月[0-9]&#123;2&#125;日/</span>).<span class="title function_">toString</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[1-9][0-9]&#123;3&#125;/</span>)+<span class="string">&#x27;-&#x27;</span>+</span><br><span class="line">                        $(<span class="string">&#x27;.mt_15, .mb_15, .mt_10, .mb_10&#x27;</span>)</span><br><span class="line">                        .<span class="title function_">text</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[1-9][0-9]&#123;3&#125;年[0-9]&#123;2&#125;月[0-9]&#123;2&#125;日/</span>).<span class="title function_">toString</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[0-9]&#123;2&#125;/g</span>)[<span class="number">2</span>]+<span class="string">&#x27;-&#x27;</span>+                        </span><br><span class="line">                        $(<span class="string">&#x27;.mt_15, .mb_15, .mt_10, .mb_10&#x27;</span>)</span><br><span class="line">                        .<span class="title function_">text</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[1-9][0-9]&#123;3&#125;年[0-9]&#123;2&#125;月[0-9]&#123;2&#125;日/</span>).<span class="title function_">toString</span>()</span><br><span class="line">                        .<span class="title function_">match</span>(<span class="regexp">/[0-9]&#123;2&#125;/g</span>)[<span class="number">3</span>]            </span><br><span class="line"></span><br><span class="line">                ).<span class="title function_">toUTCString</span>(),                                     <span class="comment">// 将时间的文本文字转换成 Date 对象</span></span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 设置缓存及时间</span></span><br><span class="line">            ctx.<span class="property">cache</span>.<span class="title function_">set</span>(itemUrl, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(single), <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 输出一篇文章的所有信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(single);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置分类的标题</span></span><br><span class="line">    <span class="keyword">let</span> info = <span class="string">&#x27;本科生通知&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;xytz&#x27;</span>) &#123;</span><br><span class="line">        info = <span class="string">&#x27;学院通知&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 访问 RSS 链接时会输出的信息</span></span><br><span class="line">    ctx.<span class="property">state</span>.<span class="property">data</span> = &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;大工软院 - &#x27;</span> + info,</span><br><span class="line">        <span class="attr">link</span>: link,</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&#x27;大工软院 - &#x27;</span> + info + <span class="string">&#x27; ssdut.dlut.edu.cn&#x27;</span>,</span><br><span class="line">        <span class="attr">item</span>: out,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>获取专属消息通知, 避免遗漏学院重要通知</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="https://oss.zaqai.com/img/Screenshot_2022-02-22-17-55-13-001_com.levelup.palabre.jpg" alt="Screenshot_2022-02-22-17-55-13-001_com.levelup.palabre" style="zoom: 33%;" /><p><img src="https://oss.zaqai.com/img/image-20220222175505752.png" alt="image-20220222175505752"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过RSSHub订阅学院通知&quot;&gt;&lt;a href=&quot;#通过RSSHub订阅学院通知&quot; class=&quot;headerlink&quot; title=&quot;通过RSSHub订阅学院通知&quot;&gt;&lt;/a&gt;通过RSSHub订阅学院通知&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;今天看到以为up主</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域解决</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3/</id>
    <published>2023-12-31T20:18:03.323Z</published>
    <updated>2024-03-07T07:50:20.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于跨域"><a href="#关于跨域" class="headerlink" title="关于跨域"></a>关于跨域</h1><p>出于安全问题考虑, 浏览器都会有跨域限制, 但这个限制只在浏览器端, 你都不想浏览器在和你的服务器交互时还和别的服务器有联系吧. </p><p>试想这样一种场景, 服务器A通过一系列认证手段信任了你的浏览器, 你的浏览器也可以自由地和服务器A交换数据. 忽然你点击某个链接, 跳转到服务器B提供的网页中, 而该网页包含一段js代码, 是去服务器A中取数据的, 这种情况下就非常危险了, 如果没有跨域限制, 浏览器就会就会将服务器A发来的数据显示出来, 服务器B也可以轻松地从服务器A取得数据(这些数据本应通过认证才可以取得).<br> <img src="https://oss.zaqai.com/img/ac56888e0a00b08b.png" alt=""></p><blockquote><p>协议 域名 端口号有一个不同, 都是跨域, 注意二级域名不同也是跨域</p></blockquote><h2 id="跨域请求分类"><a href="#跨域请求分类" class="headerlink" title="跨域请求分类"></a>跨域请求分类</h2><ul><li>简单跨域请求<ul><li>请求方法是GET、HEAD或者POST，并且当请求方法是POST时，Content-Type必须是application/x-www-form-urlencoded, multipart/form-data或着text/plain中的一个值。</li><li>请求中没有自定义HTTP头部(只有Accept、Content-Type、Accept-Language、Content-Language)</li></ul></li><li>非简单跨域请求(带预检的请求)<ul><li><em>简单跨域请求第一条的其他情况</em></li><li>请求中包含自定义HTTP头部</li></ul></li></ul><blockquote><p>对于简单跨域请求, 浏览器在请求头部增加<code>origin</code>字段, 值为js代码所在的域, 也就是上文中的服务器B, 服务器收到请求, 在响应头部增加<code>Access-Control-Allow-Origin</code>字段, 直接返回数据, 至于这个数据能否被js代码拿到, 全凭浏览器的判断, 如果响应头部<code>Access-Control-Allow-Origin</code>包含请求头部中的<code>origin</code>, 浏览器就会返回数据给js代码, 否则忽略该响应</p><p><img src="https://oss.zaqai.com/img/image-20221004223034640.png" alt="image-20221004223034640" style="zoom: 67%;" /></p><p>对于非简单跨域请求, 浏览器首先发送一个预检请求,  请求方法为options, 头部除了<code>origin</code>, 还有<code>Access-Control-Request-Headers</code>和<code>Access-Control-Request-Method:</code>, 服务器会在响应头添加以下三个字段, 响应中不包含数据. 浏览器根据响应判断, 如果通过就正常发送请求, 否则直接不发送请求</p><p><img src="https://oss.zaqai.com/img/image-20221004224840650.png" alt="image-20221004224840650" style="zoom:67%;" /></p></blockquote><p>了解以上知识后, 就能很清晰地看到, 解决跨域可以从两大方面入手—浏览器 服务器</p><h2 id="跨域实现"><a href="#跨域实现" class="headerlink" title="跨域实现"></a>跨域实现</h2><h3 id="从浏览器入手"><a href="#从浏览器入手" class="headerlink" title="从浏览器入手"></a>从浏览器入手</h3><blockquote><p>只要浏览器不进行跨域检查, 就可以实现跨域</p></blockquote><h4 id="1-关闭浏览器跨域检查-最暴力的方式"><a href="#1-关闭浏览器跨域检查-最暴力的方式" class="headerlink" title="1. 关闭浏览器跨域检查(最暴力的方式)"></a>1. 关闭浏览器跨域检查(最暴力的方式)</h4><p>可以用命令行启动浏览器, 并加一些启动参数, 我在windows上没测试成功, 看到网上有博客说mac可以</p><p>当然这种方法不太实用, 也不安全, 不过在开发调试时使用还是挺方便的</p><h4 id="2-script标签的jsonp"><a href="#2-script标签的jsonp" class="headerlink" title="2. script标签的jsonp"></a>2. script标签的jsonp</h4><blockquote><p>JSONP是JSON with Padding的略称。它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。—来源百度</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ul><li>html服务在本机5500端口, 相当于浏览器正在和5500端口交互, 去请求8080端口的服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;http://127.0.0.1:8080/index.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        show()</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>跨域资源文件在本机8080端口<br><img src="https://oss.zaqai.com/img/4c36ac839b36b1f8.png" alt=""></li></ul><blockquote><p>当我们打开html, 控制台即可见到输出, 成功跨域<br><img src="https://oss.zaqai.com/img/7365b2da99e14d83.png" alt=""></p></blockquote><h3 id="从服务端入手"><a href="#从服务端入手" class="headerlink" title="从服务端入手"></a>从服务端入手</h3><p>既然浏览器的跨域检查无可避免, 那就设法让他的检查通过</p><blockquote><p>其实原理就是在响应头部添加允许跨域的字段, 以nodejs为例, 下面这段代码等价于<code>app.use(cors())</code>, 只不过是做了一个封装, 让我们更简便地调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line"> res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"> res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line"> res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line"> res.<span class="title function_">header</span>(<span class="string">&quot;X-Powered-By&quot;</span>, <span class="string">&#x27; 3.2.1&#x27;</span>);</span><br><span class="line"> res.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line"> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-服务端配置允许跨域"><a href="#1-服务端配置允许跨域" class="headerlink" title="1. 服务端配置允许跨域"></a>1. 服务端配置允许跨域</h4><p><strong>本文章服务端使用nodejs, 其他语言也类似, springboot是通过添加注解<code>@CrossOrigin</code></strong></p><h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><ul><li>html服务在本机5500端口, 相当于浏览器正在和5500端口交互, 去请求3000端口的服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        fetch(&quot;http://localhost:3000&quot;)</span><br><span class="line">            .then(res =&gt; res.json())</span><br><span class="line">            .then(data =&gt; &#123; console.log(data) &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>服务端监听本机3000端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line">// const cors = require(&#x27;cors&#x27;)</span><br><span class="line">// app.use(cors(&#123;</span><br><span class="line">//     origin: &#x27;http://localhost:5500&#x27;,</span><br><span class="line">// &#125;))</span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123; &quot;name&quot;: &quot;zq&quot;, &quot;age&quot;: 18 &#125;)</span><br><span class="line">&#125;).listen(3000)</span><br></pre></td></tr></table></figure><blockquote><p>当我们打开html, 可以看到开头熟悉的报错. 将js文件中的注释打开(<code>app.use(cors())</code>, 允许所有origin跨域), 重新启动服务端, 即可解决<br><strong>亲测localhost 和 127.0.0.1 不能混用, 也会存在跨域</strong><br><img src="https://oss.zaqai.com/img/46cac3db2e54580e.png" alt=""></p></blockquote><h4 id="2-nginx反向代理"><a href="#2-nginx反向代理" class="headerlink" title="2. nginx反向代理"></a>2. nginx反向代理</h4><p>相当于是做了一个跳板, 使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</p><ul><li>html服务在本机5500端口, 相当于浏览器正在和5500端口交互, 去请求nginx监听的8080端口的服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        fetch(&quot;http://localhost:8080&quot;)</span><br><span class="line">            .then(res =&gt; res.json())</span><br><span class="line">            .then(data =&gt; &#123; console.log(data) &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>nginx监听8080端口, 将请求转发至服务端的3000端口<br><img src="https://oss.zaqai.com/img/aebde8e9b66f7c0b.png" alt=""></li></ul><blockquote><p>画线的头部可加可不加, 都可以实现跨域, 因为nginx已经帮我们配置好允许跨域</p></blockquote><ul><li>服务端监听本机3000端口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123; &quot;name&quot;: &quot;zq&quot;, &quot;age&quot;: 18 &#125;)</span><br><span class="line">&#125;).listen(3000)</span><br></pre></td></tr></table></figure><p><img src="https://oss.zaqai.com/img/db6b3681384ee382.png" alt=""></p><blockquote><p>参考: B站视频: <a href="https://www.bilibili.com/video/BV1Ei4y1o7jK">https://www.bilibili.com/video/BV1Ei4y1o7jK</a></p><p><a href="https://www.cnblogs.com/linxingyun/p/6772937.html#:~:text=带预检 (Preflighted">Http跨域时候预检没通过的几种原因 - jyLi - 博客园 (cnblogs.com)</a>的跨域请求需要浏览器在发送真实HTTP请求之前先发送一个OPTIONS的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在OPTIONS请求中通过Access-Control-Request-Method,Header和Access-Control-Request-Headers Header描述，此外与简单跨域请求一样，浏览器也会添加Origin Header。)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于跨域&quot;&gt;&lt;a href=&quot;#关于跨域&quot; class=&quot;headerlink&quot; title=&quot;关于跨域&quot;&gt;&lt;/a&gt;关于跨域&lt;/h1&gt;&lt;p&gt;出于安全问题考虑, 浏览器都会有跨域限制, 但这个限制只在浏览器端, 你都不想浏览器在和你的服务器交互时还和别的服务器有联系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一个ipv6+ddns</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E8%AE%B0%E4%B8%80%E4%B8%AAipv6+ddns/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E8%AE%B0%E4%B8%80%E4%B8%AAipv6+ddns/</id>
    <published>2023-12-31T20:18:03.322Z</published>
    <updated>2023-12-31T12:19:54.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一个ipv6-ddns"><a href="#记一个ipv6-ddns" class="headerlink" title="记一个ipv6+ddns"></a>记一个ipv6+ddns</h1><p>所谓ddns, 就是动态dns, 适用于服务器ip地址不固定, 过一段时间就会改变的场景</p><p>推荐使用dynv6, 我用着挺好的, 地址: <a href="https://dynv6.com/">Free dynamic DNS for IPv6 (dynv6.com)</a></p><p>虽然是英文, 但大致能看明白吧</p><h2 id="dynv6步骤"><a href="#dynv6步骤" class="headerlink" title="dynv6步骤"></a>dynv6步骤</h2><ul><li><p>首先新建域名, 在<a href="https://dynv6.com/keys">dynv6</a>中查看token</p></li><li><p>推荐使用他提供的脚本<a href="https://gist.github.com/corny/7a07f5ac901844bd20c9">gist.github.com</a>, 其他方式可自行参考他提供的API<a href="https://dynv6.com/docs/apis">dynv6 APIs</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh -e</span></span><br><span class="line">hostname=$1</span><br><span class="line">device=$2</span><br><span class="line">file=$HOME/.dynv6.addr6</span><br><span class="line">[ -e $file ] &amp;&amp; old=`cat $file`</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$hostname&quot; -o -z &quot;$token&quot; ]; then</span><br><span class="line">  echo &quot;Usage: token=&lt;your-authentication-token&gt; [netmask=64] $0 your-name.dynv6.net [device]&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$netmask&quot; ]; then</span><br><span class="line">  netmask=128</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$device&quot; ]; then</span><br><span class="line">  device=&quot;dev $device&quot;</span><br><span class="line">fi</span><br><span class="line">address=$(ip -6 addr list scope global $device | grep -v &quot; fd&quot; | sed -n &#x27;s/.*inet6 \([0-9a-f:]\+\).*/\1/p&#x27; | head -n 1)</span><br><span class="line"></span><br><span class="line">if [ -e /usr/bin/curl ]; then</span><br><span class="line">  bin=&quot;curl -fsS&quot;</span><br><span class="line">elif [ -e /usr/bin/wget ]; then</span><br><span class="line">  bin=&quot;wget -O-&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;neither curl nor wget found&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$address&quot; ]; then</span><br><span class="line">  echo &quot;no IPv6 address found&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">address with netmask</span></span><br><span class="line">current=$address/$netmask</span><br><span class="line"></span><br><span class="line">if [ &quot;$old&quot; = &quot;$current&quot; ]; then</span><br><span class="line">  echo &quot;IPv6 address unchanged&quot;</span><br><span class="line">  exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">send addresses to dynv6</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">bin <span class="string">&quot;http://dynv6.com/api/update?hostname=<span class="variable">$hostname</span>&amp;ipv6=<span class="variable">$current</span>&amp;token=<span class="variable">$token</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">bin <span class="string">&quot;http://ipv4.dynv6.com/api/update?hostname=<span class="variable">$hostname</span>&amp;ipv4=auto&amp;token=<span class="variable">$token</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">save current address</span></span><br><span class="line">echo $current &gt; $file</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>考虑到脚本的网站不是那么好打开, 在这里放上脚本. 默认ipv4 ipv6都会被上传记录, 如果只想要ipv6, 将<code>$bin &quot;http://ipv4.dynv6.com/api/update?hostname=$hostname&amp;ipv4=auto&amp;token=$token&quot;</code>删掉即可. 我是删掉了, 防止某些情况下解析到ipv4, 导致无法访问</p></blockquote><blockquote><p>脚本抓取网络接口显示的ipv6地址, 在$HOME&#x2F;.dynv6.addr6创建文件记录上次更新的ip地址, 如果再次执行更新操作, 会先判断获取的ip地址和文件中的是否一致, 如果一致便不会上传更新</p></blockquote></li><li><p>命令 <code>token=你的token ./dynv6.sh 你的域名</code></p></li></ul><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>可以设置定时任务, 如<code>0 0 * * *</code>代表每天0点</p><table><thead><tr><th align="center">分</th><th align="center">时</th><th align="center">日</th><th align="center">月</th><th align="center">周</th></tr></thead><tbody><tr><td align="center">0~59</td><td align="center">0~23</td><td align="center">1~31</td><td align="center">1~12</td><td align="center">0~7</td></tr></tbody></table><blockquote><p>周的数字为 0 或 7 时，都代表“星期天”的意思</p></blockquote><table><thead><tr><th align="center">特殊字符</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">*(星号)</td><td align="center">代表任何时刻都接受的意思。举例来说，0 12 * * * command 日、月、周都是*，就代表着不论何月、何日的礼拜几的12：00都执行后续命令的意思。</td></tr><tr><td align="center">,(逗号)</td><td align="center">代表分隔时段的意思。举例来说，如果要执行的工作是3：00与6：00时，就会是：0 3,6 * * * command时间还是有五列，不过第二列是 3,6 ，代表3与6都适用</td></tr><tr><td align="center">-(减号)</td><td align="center">代表一段时间范围内，举例来说，8点到12点之间的每小时的20分都进行一项工作：20 8-12 * * * command仔细看到第二列变成8-12.代表 8,9,10,11,12 都适用的意思</td></tr><tr><td align="center">&#x2F;n(斜线)</td><td align="center">那个n代表数字，即是每隔n单位间隔的意思，例如每五分钟进行一次，则：*&#x2F;5 * * * * command用*与&#x2F;5来搭配，也可以写成0-59&#x2F;5，意思相同</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记一个ipv6-ddns&quot;&gt;&lt;a href=&quot;#记一个ipv6-ddns&quot; class=&quot;headerlink&quot; title=&quot;记一个ipv6+ddns&quot;&gt;&lt;/a&gt;记一个ipv6+ddns&lt;/h1&gt;&lt;p&gt;所谓ddns, 就是动态dns, 适用于服务器ip地址不固定</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编程心得</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E7%BC%96%E7%A8%8B%E5%BF%83%E5%BE%97/</id>
    <published>2023-12-31T20:18:03.320Z</published>
    <updated>2023-12-31T12:19:52.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则匹配关键字符"><a href="#正则匹配关键字符" class="headerlink" title="正则匹配关键字符"></a>正则匹配关键字符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;/data/cache/style_1_common.css?y7a&quot;;</span><br><span class="line">System.out.println(s.split(&quot;\\?&quot;)[0]);</span><br></pre></td></tr></table></figure><blockquote><p><code>split(&quot;?&quot;) split(&quot;\?&quot;) split(&quot;/?&quot;)</code>都不行<br><code>split(&quot;\\?&quot;) split(&quot;[?]&quot;)</code>行</p></blockquote><h2 id="C-关于NULL和nullptr"><a href="#C-关于NULL和nullptr" class="headerlink" title="C++关于NULL和nullptr"></a>C++关于NULL和nullptr</h2><blockquote><p>NULL在C语言被定义为<code>#define NULL ((void *)0)</code>,可以发生隐式类型转换(<code> int  *pi = NULL;</code>)<br>nullptr是在C++中引入的,代表空指针,因为C++是强类型语言,void*是不能隐式转换成其他类型的指针的,所以NULL会被解释为0</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void func(int x) &#123;</span><br><span class="line">    cout&lt;&lt;&quot;void func(int x)&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func(char *y) &#123;</span><br><span class="line">    cout&lt;&lt;&quot;void func(int *y)&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会有重载二义性错误,换成nullptr就没问题<br><strong>不用NULL,用nullptr</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则匹配关键字符&quot;&gt;&lt;a href=&quot;#正则匹配关键字符&quot; class=&quot;headerlink&quot; title=&quot;正则匹配关键字符&quot;&gt;&lt;/a&gt;正则匹配关键字符&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>牛客刷题笔记</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E7%89%9B%E5%AE%A2%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-31T20:18:03.319Z</published>
    <updated>2023-12-31T12:19:55.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛客刷题笔记"><a href="#牛客刷题笔记" class="headerlink" title="牛客刷题笔记"></a>牛客刷题笔记</h1><ul><li>抽象类 特点: <ul><li>1.抽象类中可以有构造方法 </li><li>2.抽象类中可以存在普通属性，方法，静态属性和方法。 </li><li>3.抽象类中可以存在抽象方法。</li><li>4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法</li><li>5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。</li></ul></li><li>接口 </li><li>1.在接口中只有方法的声明，没有方法体。 </li><li>2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上 &#x3D;&#x3D;public static final&#x3D;&#x3D;  </li><li>3.在接口中的方法，永远都被public来修饰。</li><li>4.接口中没有构造方法，也不能实例化接口的对象。 </li><li>5.接口可以实现多继承 </li><li>6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法 </li><li>7.则实现类定义为抽象类。</li><li>线程私有:java虚拟机栈，程序计数器，本地方法栈 </li><li>线程共享:java堆，方法区</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;牛客刷题笔记&quot;&gt;&lt;a href=&quot;#牛客刷题笔记&quot; class=&quot;headerlink&quot; title=&quot;牛客刷题笔记&quot;&gt;&lt;/a&gt;牛客刷题笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;抽象类 特点: &lt;ul&gt;
&lt;li&gt;1.抽象类中可以有构造方法 &lt;/li&gt;
&lt;li&gt;2.抽象类中可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>斐讯n1安装centos7+docker openwrt</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E6%96%90%E8%AE%AFn1%E5%AE%89%E8%A3%85centos7+docker%20openwrt/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E6%96%90%E8%AE%AFn1%E5%AE%89%E8%A3%85centos7+docker%20openwrt/</id>
    <published>2023-12-31T20:18:03.311Z</published>
    <updated>2023-12-31T12:19:53.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斐讯n1安装centos7-docker-openwrt"><a href="#斐讯n1安装centos7-docker-openwrt" class="headerlink" title="斐讯n1安装centos7+docker openwrt"></a>斐讯n1安装centos7+docker openwrt</h1><blockquote><p>首先声明,我的n1是降级过的,系统默认usb启动优先级大于emmc,所以可以直接将镜像写入u盘,通过u盘启动系统,同时通过脚本将系统写入emmc.</p><p>同时,由于n1的usb是2.0,推荐将常用系统写入emmc,而不是通过u盘启动(虽然emmc只有8G).亲测速度快的不是一点半点,最直观的感受就是执行<code>yum update</code>.</p></blockquote><h3 id="centos镜像"><a href="#centos镜像" class="headerlink" title="centos镜像"></a>centos镜像</h3><p><a href="https://www.right.com.cn/forum/thread-4061041-1-7.html">N1盒子 CentOS7.9系统镜像，支持写入EMMC - 斐讯无线路由器以及其它斐迅网络设备 - 恩山无线论坛 - Powered by Discuz! (right.com.cn)</a></p><p>同时附上论坛上的简单教程:</p><p><a href="https://www.right.com.cn/forum/thread-6804025-1-1.html">分享N1盒子CentOS7.9系统下安装最新版本的宝塔面板linux7.7简单教程 - 斐讯无线路由器以及其它斐迅网络设备 - 恩山无线论坛 - Powered by Discuz! (right.com.cn)</a></p><p><strong>特别感谢恩山论坛的各位大佬!</strong></p><blockquote><p>在此我也简单记录一下,以防某天重装系统:joy:</p></blockquote><p>修改写入emmc的脚本,添加上复制lib64文件夹的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /root/.install_os_to_emmc/install.sh</span><br><span class="line"></span><br><span class="line">在153行后添加下面命令</span><br><span class="line"></span><br><span class="line">echo &quot;Copy LIB64...&quot;</span><br><span class="line">tar -cf - lib64 | (cd $DIR_INSTALL; tar -xpf -)</span><br></pre></td></tr></table></figure><p><img src="https://oss.zaqai.com/img/image-20220116094823830.png" alt="image-20220116094823830"></p><h3 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h3><blockquote><p>禁止宝塔打开swap内存,纯净系统只占用200-300MB内存,对于n1的2G内存来说,基本上够用了,何况8G的emmc也很稀缺</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改宝塔安装脚本</span><br><span class="line">删除或注释掉以下三条命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;MEM_TOTAL&#125;</span>&quot;</span> -le <span class="string">&quot;1&quot;</span> ];<span class="keyword">then</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       Auto_Swap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure><p>关于宝塔安装nginx和php,听说是编译安装性能更优,只是安装较慢,本人亲测Nginx 1.20.2  Nginx 1.18  php7.4均可编译安装成功</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>网上也有很多教程,我就直接一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h3 id="docker安装openwrt"><a href="#docker安装openwrt" class="headerlink" title="docker安装openwrt"></a>docker安装openwrt</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先开启网卡混杂模式</span><br><span class="line">ip link set eth0 promisc on</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建vlan</span></span><br><span class="line">docker network create -d macvlan --subnet=192.168.10.0/24 --gateway=192.168.10.1 -o parent=eth0 macnet</span><br></pre></td></tr></table></figure><p>网段与主路由相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart always --name openwrt -d --network macnet --privileged sulinggg/openwrt:latest /sbin/init</span><br><span class="line">此时openwrt已在运行</span><br><span class="line">进入容器修改lan接口</span><br><span class="line">docker exec -it openwrt bash</span><br><span class="line">vi /etc/config/network</span><br></pre></td></tr></table></figure><p>只需修改<code>config interface &#39;lan&#39;</code>中的配置</p><p>ipaddr为主路由网段下的一个ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">option ipaddr &#x27;192.168.1.111&#x27;</span><br><span class="line">option gateway &#x27;192.168.1.1&#x27;</span><br><span class="line">option dns &#x27;192.168.1.1&#x27;</span><br></pre></td></tr></table></figure><p>重启<code>/etc/init.d/network restart</code>之后就可以在浏览器输入<code>192.168.1.111</code>进入openwrt管理页面,默认密码为password</p><h3 id="关于旁路网关上网"><a href="#关于旁路网关上网" class="headerlink" title="关于旁路网关上网"></a>关于旁路网关上网</h3><p>使用<code>服务</code>-&gt;<code>PassWall</code>操作就行,实际上就是一个代理工具客户端</p><p>配置好之后,只需在设备上修改为静态ip,注意网关和DNS都要改为openwrt的ip<code>192.168.1.111</code>,大功告成,可以去测试一下</p><p><font color="red">记得去接口里把桥接关掉!!!</font></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>解决宿主机无法和docker的macvlan通信</p><blockquote><p><a href="https://piaoyun.cc/1527.html">Docker的macvlan模式容器与宿主机通信问题-飘云 (piaoyun.cc)</a></p><p><a href="https://smalloutcome.com/2021/07/18/Docker-%E4%BD%BF%E7%94%A8-macvlan-%E7%BD%91%E7%BB%9C%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/">Docker 使用 macvlan 网络容器与宿主机的通信过程 | 一小步 (smalloutcome.com)</a></p></blockquote><p>一句话:</p><blockquote><p>mavlan 虚拟出来的网口不能和父网口直通，但是可以和同一子网的其他网口互通（包括其他虚拟出来的网口）。</p><p>通过在宿主机上用 macvlan 添加一个虚拟网口 mynet ，并在宿主机上配置路由到容器的数据包由 mynet 发出，就架起了宿主机与容器的通信桥梁。<br>宿主机发往容器的数据包，由 mynet 发给容器；容器发往宿主机的数据包先发给 mynet，再由 mynet 转交给 eth0。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip link add mynet link eth0 type macvlan mode bridge</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip addr add 192.168.1.112 dev mynet</span></span><br><span class="line">ip link set mynet up</span><br><span class="line">ip route add 192.168.1.111 dev mynet</span><br></pre></td></tr></table></figure><p>至此, 宿主机和容器应该是能互相ping通</p></li><li><p>解决宿主机使用openwrt网关时无法联网</p><blockquote><p><a href="https://github.com/lisaac/blog/issues/4">在docker中运行openwrt · Issue #4 · lisaac&#x2F;blog (github.com)</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route del default #删除默认路由</span><br><span class="line">ip route add default via 192.168.1.111 dev mynet # 设置静态路由</span><br></pre></td></tr></table></figure></li></ol><h4 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h4><blockquote><p>我们使用代理时,软件将我们的网络请求拦截,进而向代理服务器发送请求,代理服务器再向我们的目标服务器发送我们被软件拦截的原始请求,最后再返回</p><p>使用旁路网关时,我们的设备首先将请求发送至openwrt,在openwrt端一番操作再返回</p><p>两种方式本质都是一样的,只是第一种一个设备一个代理,第二种多个设备一个代理,对我们的使用体验来说,当然是第二种更好</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://mlapp.cn/376.html">在Docker 中运行 OpenWrt 旁路网关 | 美丽应用 (mlapp.cn)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;斐讯n1安装centos7-docker-openwrt&quot;&gt;&lt;a href=&quot;#斐讯n1安装centos7-docker-openwrt&quot; class=&quot;headerlink&quot; title=&quot;斐讯n1安装centos7+docker openwrt&quot;&gt;&lt;/a&gt;斐讯</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>家用电器功率统计</title>
    <link href="https://blog.zaqai.com/2024/01/01/%E5%AE%B6%E7%94%A8%E7%94%B5%E5%99%A8%E5%8A%9F%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    <id>https://blog.zaqai.com/2024/01/01/%E5%AE%B6%E7%94%A8%E7%94%B5%E5%99%A8%E5%8A%9F%E7%8E%87%E7%BB%9F%E8%AE%A1/</id>
    <published>2023-12-31T20:18:03.304Z</published>
    <updated>2023-12-31T12:19:54.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="家用电器功率统计"><a href="#家用电器功率统计" class="headerlink" title="家用电器功率统计"></a>家用电器功率统计</h1><h2 id="冰箱"><a href="#冰箱" class="headerlink" title="冰箱"></a>冰箱</h2><blockquote><p>夜晚测量, 未打开过冰箱</p></blockquote><p><img src="https://oss.zaqai.com/img/image-20220805165619292.png" alt="image-20220805165619292"></p><p><img src="https://oss.zaqai.com/img/image-20220805155434589.png" alt="image-20220805155434589"></p><p>工作(85+80+78)&#x2F;3&#x3D;81min, 停止(67+69+71)&#x2F;3&#x3D;69min, 工作时间占比8&#x2F;15</p><p>工作时平均功率50w</p><p>一月大概消耗19度电</p><h2 id="冰柜"><a href="#冰柜" class="headerlink" title="冰柜"></a>冰柜</h2><blockquote><p>白天测量, 大概打开冰柜一次</p></blockquote><p><img src="https://oss.zaqai.com/img/image-20220805165508081.png" alt="image-20220805165508081"></p><p><img src="https://oss.zaqai.com/img/image-20220805154752162.png" alt="image-20220805154752162"></p><p>工作(14+14+25+17)&#x2F;4&#x3D;17.5min, 停止(24+23+18+21)&#x2F;4&#x3D;21.5min, 工作时间占比0.45</p><p>工作时平均功率80w</p><p>一月大概消耗26度电</p><h2 id="米家摄像头"><a href="#米家摄像头" class="headerlink" title="米家摄像头"></a>米家摄像头</h2><p><img src="https://oss.zaqai.com/img/image-20220805163303418.png" alt="image-20220805163303418"></p><p>2w!</p><h2 id="电风扇"><a href="#电风扇" class="headerlink" title="电风扇"></a>电风扇</h2><blockquote><p>不摇头</p></blockquote><p><img src="https://oss.zaqai.com/img/image-20220805165906206.png" alt="image-20220805165906206"></p><p>2档功率48w, 1档功率46w, 差别不大啊</p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><blockquote><p>中间看了一段视频</p></blockquote><p><img src="https://oss.zaqai.com/img/image-20220805174727491.png"></p><p><img src="https://oss.zaqai.com/img/image-20220805174204635.png" alt="image-20220805174204635"></p><p>权当6.5w吧</p><h2 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h2><p><img src="https://oss.zaqai.com/img/image-20220805174834318.png" alt="image-20220805174834318"></p><p><img src="https://oss.zaqai.com/img/image-20220805175659137.png" alt="image-20220805175659137"></p><p>2w吧</p><h2 id="外面摄像头"><a href="#外面摄像头" class="headerlink" title="外面摄像头"></a>外面摄像头</h2><p><img src="https://oss.zaqai.com/img/image-20220805213014673.png" alt="image-20220805213014673"></p><p>大概是夜晚开启夜视功能, 功率变高了, 算作4w吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;家用电器功率统计&quot;&gt;&lt;a href=&quot;#家用电器功率统计&quot; class=&quot;headerlink&quot; title=&quot;家用电器功率统计&quot;&gt;&lt;/a&gt;家用电器功率统计&lt;/h1&gt;&lt;h2 id=&quot;冰箱&quot;&gt;&lt;a href=&quot;#冰箱&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
</feed>
